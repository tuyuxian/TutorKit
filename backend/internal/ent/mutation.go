// Code generated by ent, DO NOT EDIT.

package ent

import (
	"backend/internal/ent/entattendance"
	"backend/internal/ent/entcomment"
	"backend/internal/ent/entcourse"
	"backend/internal/ent/entpost"
	"backend/internal/ent/enttodo"
	"backend/internal/ent/entuser"
	"backend/internal/ent/predicate"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeEntAttendance = "EntAttendance"
	TypeEntComment    = "EntComment"
	TypeEntCourse     = "EntCourse"
	TypeEntPost       = "EntPost"
	TypeEntTodo       = "EntTodo"
	TypeEntUser       = "EntUser"
)

// EntAttendanceMutation represents an operation that mutates the EntAttendance nodes in the graph.
type EntAttendanceMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	date                 *time.Time
	startTime            *time.Time
	endTime              *time.Time
	day                  *time.Time
	note                 *string
	hours                *float64
	addhours             *float64
	checkedByTutor       *bool
	checkedByStudent     *bool
	checkedByParent      *bool
	clearedFields        map[string]struct{}
	attendanceFor        *int
	clearedattendanceFor bool
	ownedBy              *int
	clearedownedBy       bool
	done                 bool
	oldValue             func(context.Context) (*EntAttendance, error)
	predicates           []predicate.EntAttendance
}

var _ ent.Mutation = (*EntAttendanceMutation)(nil)

// entattendanceOption allows management of the mutation configuration using functional options.
type entattendanceOption func(*EntAttendanceMutation)

// newEntAttendanceMutation creates new mutation for the EntAttendance entity.
func newEntAttendanceMutation(c config, op Op, opts ...entattendanceOption) *EntAttendanceMutation {
	m := &EntAttendanceMutation{
		config:        c,
		op:            op,
		typ:           TypeEntAttendance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntAttendanceID sets the ID field of the mutation.
func withEntAttendanceID(id int) entattendanceOption {
	return func(m *EntAttendanceMutation) {
		var (
			err   error
			once  sync.Once
			value *EntAttendance
		)
		m.oldValue = func(ctx context.Context) (*EntAttendance, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EntAttendance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntAttendance sets the old EntAttendance of the mutation.
func withEntAttendance(node *EntAttendance) entattendanceOption {
	return func(m *EntAttendanceMutation) {
		m.oldValue = func(context.Context) (*EntAttendance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntAttendanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntAttendanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EntAttendanceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EntAttendanceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EntAttendance.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDate sets the "date" field.
func (m *EntAttendanceMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *EntAttendanceMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the EntAttendance entity.
// If the EntAttendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntAttendanceMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *EntAttendanceMutation) ResetDate() {
	m.date = nil
}

// SetStartTime sets the "startTime" field.
func (m *EntAttendanceMutation) SetStartTime(t time.Time) {
	m.startTime = &t
}

// StartTime returns the value of the "startTime" field in the mutation.
func (m *EntAttendanceMutation) StartTime() (r time.Time, exists bool) {
	v := m.startTime
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "startTime" field's value of the EntAttendance entity.
// If the EntAttendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntAttendanceMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ClearStartTime clears the value of the "startTime" field.
func (m *EntAttendanceMutation) ClearStartTime() {
	m.startTime = nil
	m.clearedFields[entattendance.FieldStartTime] = struct{}{}
}

// StartTimeCleared returns if the "startTime" field was cleared in this mutation.
func (m *EntAttendanceMutation) StartTimeCleared() bool {
	_, ok := m.clearedFields[entattendance.FieldStartTime]
	return ok
}

// ResetStartTime resets all changes to the "startTime" field.
func (m *EntAttendanceMutation) ResetStartTime() {
	m.startTime = nil
	delete(m.clearedFields, entattendance.FieldStartTime)
}

// SetEndTime sets the "endTime" field.
func (m *EntAttendanceMutation) SetEndTime(t time.Time) {
	m.endTime = &t
}

// EndTime returns the value of the "endTime" field in the mutation.
func (m *EntAttendanceMutation) EndTime() (r time.Time, exists bool) {
	v := m.endTime
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "endTime" field's value of the EntAttendance entity.
// If the EntAttendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntAttendanceMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ClearEndTime clears the value of the "endTime" field.
func (m *EntAttendanceMutation) ClearEndTime() {
	m.endTime = nil
	m.clearedFields[entattendance.FieldEndTime] = struct{}{}
}

// EndTimeCleared returns if the "endTime" field was cleared in this mutation.
func (m *EntAttendanceMutation) EndTimeCleared() bool {
	_, ok := m.clearedFields[entattendance.FieldEndTime]
	return ok
}

// ResetEndTime resets all changes to the "endTime" field.
func (m *EntAttendanceMutation) ResetEndTime() {
	m.endTime = nil
	delete(m.clearedFields, entattendance.FieldEndTime)
}

// SetDay sets the "day" field.
func (m *EntAttendanceMutation) SetDay(t time.Time) {
	m.day = &t
}

// Day returns the value of the "day" field in the mutation.
func (m *EntAttendanceMutation) Day() (r time.Time, exists bool) {
	v := m.day
	if v == nil {
		return
	}
	return *v, true
}

// OldDay returns the old "day" field's value of the EntAttendance entity.
// If the EntAttendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntAttendanceMutation) OldDay(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDay: %w", err)
	}
	return oldValue.Day, nil
}

// ClearDay clears the value of the "day" field.
func (m *EntAttendanceMutation) ClearDay() {
	m.day = nil
	m.clearedFields[entattendance.FieldDay] = struct{}{}
}

// DayCleared returns if the "day" field was cleared in this mutation.
func (m *EntAttendanceMutation) DayCleared() bool {
	_, ok := m.clearedFields[entattendance.FieldDay]
	return ok
}

// ResetDay resets all changes to the "day" field.
func (m *EntAttendanceMutation) ResetDay() {
	m.day = nil
	delete(m.clearedFields, entattendance.FieldDay)
}

// SetNote sets the "note" field.
func (m *EntAttendanceMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *EntAttendanceMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the EntAttendance entity.
// If the EntAttendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntAttendanceMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *EntAttendanceMutation) ClearNote() {
	m.note = nil
	m.clearedFields[entattendance.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *EntAttendanceMutation) NoteCleared() bool {
	_, ok := m.clearedFields[entattendance.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *EntAttendanceMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, entattendance.FieldNote)
}

// SetHours sets the "hours" field.
func (m *EntAttendanceMutation) SetHours(f float64) {
	m.hours = &f
	m.addhours = nil
}

// Hours returns the value of the "hours" field in the mutation.
func (m *EntAttendanceMutation) Hours() (r float64, exists bool) {
	v := m.hours
	if v == nil {
		return
	}
	return *v, true
}

// OldHours returns the old "hours" field's value of the EntAttendance entity.
// If the EntAttendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntAttendanceMutation) OldHours(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHours: %w", err)
	}
	return oldValue.Hours, nil
}

// AddHours adds f to the "hours" field.
func (m *EntAttendanceMutation) AddHours(f float64) {
	if m.addhours != nil {
		*m.addhours += f
	} else {
		m.addhours = &f
	}
}

// AddedHours returns the value that was added to the "hours" field in this mutation.
func (m *EntAttendanceMutation) AddedHours() (r float64, exists bool) {
	v := m.addhours
	if v == nil {
		return
	}
	return *v, true
}

// ClearHours clears the value of the "hours" field.
func (m *EntAttendanceMutation) ClearHours() {
	m.hours = nil
	m.addhours = nil
	m.clearedFields[entattendance.FieldHours] = struct{}{}
}

// HoursCleared returns if the "hours" field was cleared in this mutation.
func (m *EntAttendanceMutation) HoursCleared() bool {
	_, ok := m.clearedFields[entattendance.FieldHours]
	return ok
}

// ResetHours resets all changes to the "hours" field.
func (m *EntAttendanceMutation) ResetHours() {
	m.hours = nil
	m.addhours = nil
	delete(m.clearedFields, entattendance.FieldHours)
}

// SetCheckedByTutor sets the "checkedByTutor" field.
func (m *EntAttendanceMutation) SetCheckedByTutor(b bool) {
	m.checkedByTutor = &b
}

// CheckedByTutor returns the value of the "checkedByTutor" field in the mutation.
func (m *EntAttendanceMutation) CheckedByTutor() (r bool, exists bool) {
	v := m.checkedByTutor
	if v == nil {
		return
	}
	return *v, true
}

// OldCheckedByTutor returns the old "checkedByTutor" field's value of the EntAttendance entity.
// If the EntAttendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntAttendanceMutation) OldCheckedByTutor(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCheckedByTutor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCheckedByTutor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheckedByTutor: %w", err)
	}
	return oldValue.CheckedByTutor, nil
}

// ResetCheckedByTutor resets all changes to the "checkedByTutor" field.
func (m *EntAttendanceMutation) ResetCheckedByTutor() {
	m.checkedByTutor = nil
}

// SetCheckedByStudent sets the "checkedByStudent" field.
func (m *EntAttendanceMutation) SetCheckedByStudent(b bool) {
	m.checkedByStudent = &b
}

// CheckedByStudent returns the value of the "checkedByStudent" field in the mutation.
func (m *EntAttendanceMutation) CheckedByStudent() (r bool, exists bool) {
	v := m.checkedByStudent
	if v == nil {
		return
	}
	return *v, true
}

// OldCheckedByStudent returns the old "checkedByStudent" field's value of the EntAttendance entity.
// If the EntAttendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntAttendanceMutation) OldCheckedByStudent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCheckedByStudent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCheckedByStudent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheckedByStudent: %w", err)
	}
	return oldValue.CheckedByStudent, nil
}

// ResetCheckedByStudent resets all changes to the "checkedByStudent" field.
func (m *EntAttendanceMutation) ResetCheckedByStudent() {
	m.checkedByStudent = nil
}

// SetCheckedByParent sets the "checkedByParent" field.
func (m *EntAttendanceMutation) SetCheckedByParent(b bool) {
	m.checkedByParent = &b
}

// CheckedByParent returns the value of the "checkedByParent" field in the mutation.
func (m *EntAttendanceMutation) CheckedByParent() (r bool, exists bool) {
	v := m.checkedByParent
	if v == nil {
		return
	}
	return *v, true
}

// OldCheckedByParent returns the old "checkedByParent" field's value of the EntAttendance entity.
// If the EntAttendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntAttendanceMutation) OldCheckedByParent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCheckedByParent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCheckedByParent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheckedByParent: %w", err)
	}
	return oldValue.CheckedByParent, nil
}

// ResetCheckedByParent resets all changes to the "checkedByParent" field.
func (m *EntAttendanceMutation) ResetCheckedByParent() {
	m.checkedByParent = nil
}

// SetAttendanceForID sets the "attendanceFor" edge to the EntCourse entity by id.
func (m *EntAttendanceMutation) SetAttendanceForID(id int) {
	m.attendanceFor = &id
}

// ClearAttendanceFor clears the "attendanceFor" edge to the EntCourse entity.
func (m *EntAttendanceMutation) ClearAttendanceFor() {
	m.clearedattendanceFor = true
}

// AttendanceForCleared reports if the "attendanceFor" edge to the EntCourse entity was cleared.
func (m *EntAttendanceMutation) AttendanceForCleared() bool {
	return m.clearedattendanceFor
}

// AttendanceForID returns the "attendanceFor" edge ID in the mutation.
func (m *EntAttendanceMutation) AttendanceForID() (id int, exists bool) {
	if m.attendanceFor != nil {
		return *m.attendanceFor, true
	}
	return
}

// AttendanceForIDs returns the "attendanceFor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AttendanceForID instead. It exists only for internal usage by the builders.
func (m *EntAttendanceMutation) AttendanceForIDs() (ids []int) {
	if id := m.attendanceFor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAttendanceFor resets all changes to the "attendanceFor" edge.
func (m *EntAttendanceMutation) ResetAttendanceFor() {
	m.attendanceFor = nil
	m.clearedattendanceFor = false
}

// SetOwnedByID sets the "ownedBy" edge to the EntUser entity by id.
func (m *EntAttendanceMutation) SetOwnedByID(id int) {
	m.ownedBy = &id
}

// ClearOwnedBy clears the "ownedBy" edge to the EntUser entity.
func (m *EntAttendanceMutation) ClearOwnedBy() {
	m.clearedownedBy = true
}

// OwnedByCleared reports if the "ownedBy" edge to the EntUser entity was cleared.
func (m *EntAttendanceMutation) OwnedByCleared() bool {
	return m.clearedownedBy
}

// OwnedByID returns the "ownedBy" edge ID in the mutation.
func (m *EntAttendanceMutation) OwnedByID() (id int, exists bool) {
	if m.ownedBy != nil {
		return *m.ownedBy, true
	}
	return
}

// OwnedByIDs returns the "ownedBy" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnedByID instead. It exists only for internal usage by the builders.
func (m *EntAttendanceMutation) OwnedByIDs() (ids []int) {
	if id := m.ownedBy; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwnedBy resets all changes to the "ownedBy" edge.
func (m *EntAttendanceMutation) ResetOwnedBy() {
	m.ownedBy = nil
	m.clearedownedBy = false
}

// Where appends a list predicates to the EntAttendanceMutation builder.
func (m *EntAttendanceMutation) Where(ps ...predicate.EntAttendance) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EntAttendanceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (EntAttendance).
func (m *EntAttendanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EntAttendanceMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.date != nil {
		fields = append(fields, entattendance.FieldDate)
	}
	if m.startTime != nil {
		fields = append(fields, entattendance.FieldStartTime)
	}
	if m.endTime != nil {
		fields = append(fields, entattendance.FieldEndTime)
	}
	if m.day != nil {
		fields = append(fields, entattendance.FieldDay)
	}
	if m.note != nil {
		fields = append(fields, entattendance.FieldNote)
	}
	if m.hours != nil {
		fields = append(fields, entattendance.FieldHours)
	}
	if m.checkedByTutor != nil {
		fields = append(fields, entattendance.FieldCheckedByTutor)
	}
	if m.checkedByStudent != nil {
		fields = append(fields, entattendance.FieldCheckedByStudent)
	}
	if m.checkedByParent != nil {
		fields = append(fields, entattendance.FieldCheckedByParent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EntAttendanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entattendance.FieldDate:
		return m.Date()
	case entattendance.FieldStartTime:
		return m.StartTime()
	case entattendance.FieldEndTime:
		return m.EndTime()
	case entattendance.FieldDay:
		return m.Day()
	case entattendance.FieldNote:
		return m.Note()
	case entattendance.FieldHours:
		return m.Hours()
	case entattendance.FieldCheckedByTutor:
		return m.CheckedByTutor()
	case entattendance.FieldCheckedByStudent:
		return m.CheckedByStudent()
	case entattendance.FieldCheckedByParent:
		return m.CheckedByParent()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EntAttendanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entattendance.FieldDate:
		return m.OldDate(ctx)
	case entattendance.FieldStartTime:
		return m.OldStartTime(ctx)
	case entattendance.FieldEndTime:
		return m.OldEndTime(ctx)
	case entattendance.FieldDay:
		return m.OldDay(ctx)
	case entattendance.FieldNote:
		return m.OldNote(ctx)
	case entattendance.FieldHours:
		return m.OldHours(ctx)
	case entattendance.FieldCheckedByTutor:
		return m.OldCheckedByTutor(ctx)
	case entattendance.FieldCheckedByStudent:
		return m.OldCheckedByStudent(ctx)
	case entattendance.FieldCheckedByParent:
		return m.OldCheckedByParent(ctx)
	}
	return nil, fmt.Errorf("unknown EntAttendance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntAttendanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entattendance.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case entattendance.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case entattendance.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case entattendance.FieldDay:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDay(v)
		return nil
	case entattendance.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case entattendance.FieldHours:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHours(v)
		return nil
	case entattendance.FieldCheckedByTutor:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheckedByTutor(v)
		return nil
	case entattendance.FieldCheckedByStudent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheckedByStudent(v)
		return nil
	case entattendance.FieldCheckedByParent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheckedByParent(v)
		return nil
	}
	return fmt.Errorf("unknown EntAttendance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EntAttendanceMutation) AddedFields() []string {
	var fields []string
	if m.addhours != nil {
		fields = append(fields, entattendance.FieldHours)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EntAttendanceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case entattendance.FieldHours:
		return m.AddedHours()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntAttendanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case entattendance.FieldHours:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHours(v)
		return nil
	}
	return fmt.Errorf("unknown EntAttendance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EntAttendanceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(entattendance.FieldStartTime) {
		fields = append(fields, entattendance.FieldStartTime)
	}
	if m.FieldCleared(entattendance.FieldEndTime) {
		fields = append(fields, entattendance.FieldEndTime)
	}
	if m.FieldCleared(entattendance.FieldDay) {
		fields = append(fields, entattendance.FieldDay)
	}
	if m.FieldCleared(entattendance.FieldNote) {
		fields = append(fields, entattendance.FieldNote)
	}
	if m.FieldCleared(entattendance.FieldHours) {
		fields = append(fields, entattendance.FieldHours)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EntAttendanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntAttendanceMutation) ClearField(name string) error {
	switch name {
	case entattendance.FieldStartTime:
		m.ClearStartTime()
		return nil
	case entattendance.FieldEndTime:
		m.ClearEndTime()
		return nil
	case entattendance.FieldDay:
		m.ClearDay()
		return nil
	case entattendance.FieldNote:
		m.ClearNote()
		return nil
	case entattendance.FieldHours:
		m.ClearHours()
		return nil
	}
	return fmt.Errorf("unknown EntAttendance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EntAttendanceMutation) ResetField(name string) error {
	switch name {
	case entattendance.FieldDate:
		m.ResetDate()
		return nil
	case entattendance.FieldStartTime:
		m.ResetStartTime()
		return nil
	case entattendance.FieldEndTime:
		m.ResetEndTime()
		return nil
	case entattendance.FieldDay:
		m.ResetDay()
		return nil
	case entattendance.FieldNote:
		m.ResetNote()
		return nil
	case entattendance.FieldHours:
		m.ResetHours()
		return nil
	case entattendance.FieldCheckedByTutor:
		m.ResetCheckedByTutor()
		return nil
	case entattendance.FieldCheckedByStudent:
		m.ResetCheckedByStudent()
		return nil
	case entattendance.FieldCheckedByParent:
		m.ResetCheckedByParent()
		return nil
	}
	return fmt.Errorf("unknown EntAttendance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EntAttendanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.attendanceFor != nil {
		edges = append(edges, entattendance.EdgeAttendanceFor)
	}
	if m.ownedBy != nil {
		edges = append(edges, entattendance.EdgeOwnedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EntAttendanceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case entattendance.EdgeAttendanceFor:
		if id := m.attendanceFor; id != nil {
			return []ent.Value{*id}
		}
	case entattendance.EdgeOwnedBy:
		if id := m.ownedBy; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EntAttendanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EntAttendanceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EntAttendanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedattendanceFor {
		edges = append(edges, entattendance.EdgeAttendanceFor)
	}
	if m.clearedownedBy {
		edges = append(edges, entattendance.EdgeOwnedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EntAttendanceMutation) EdgeCleared(name string) bool {
	switch name {
	case entattendance.EdgeAttendanceFor:
		return m.clearedattendanceFor
	case entattendance.EdgeOwnedBy:
		return m.clearedownedBy
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EntAttendanceMutation) ClearEdge(name string) error {
	switch name {
	case entattendance.EdgeAttendanceFor:
		m.ClearAttendanceFor()
		return nil
	case entattendance.EdgeOwnedBy:
		m.ClearOwnedBy()
		return nil
	}
	return fmt.Errorf("unknown EntAttendance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EntAttendanceMutation) ResetEdge(name string) error {
	switch name {
	case entattendance.EdgeAttendanceFor:
		m.ResetAttendanceFor()
		return nil
	case entattendance.EdgeOwnedBy:
		m.ResetOwnedBy()
		return nil
	}
	return fmt.Errorf("unknown EntAttendance edge %s", name)
}

// EntCommentMutation represents an operation that mutates the EntComment nodes in the graph.
type EntCommentMutation struct {
	config
	op               Op
	typ              string
	id               *int
	timestamp        *time.Time
	content          *string
	share            *entcomment.Share
	clearedFields    map[string]struct{}
	belongsTo        *int
	clearedbelongsTo bool
	ownedBy          *int
	clearedownedBy   bool
	done             bool
	oldValue         func(context.Context) (*EntComment, error)
	predicates       []predicate.EntComment
}

var _ ent.Mutation = (*EntCommentMutation)(nil)

// entcommentOption allows management of the mutation configuration using functional options.
type entcommentOption func(*EntCommentMutation)

// newEntCommentMutation creates new mutation for the EntComment entity.
func newEntCommentMutation(c config, op Op, opts ...entcommentOption) *EntCommentMutation {
	m := &EntCommentMutation{
		config:        c,
		op:            op,
		typ:           TypeEntComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntCommentID sets the ID field of the mutation.
func withEntCommentID(id int) entcommentOption {
	return func(m *EntCommentMutation) {
		var (
			err   error
			once  sync.Once
			value *EntComment
		)
		m.oldValue = func(ctx context.Context) (*EntComment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EntComment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntComment sets the old EntComment of the mutation.
func withEntComment(node *EntComment) entcommentOption {
	return func(m *EntCommentMutation) {
		m.oldValue = func(context.Context) (*EntComment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntCommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntCommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EntCommentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EntCommentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EntComment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTimestamp sets the "timestamp" field.
func (m *EntCommentMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *EntCommentMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the EntComment entity.
// If the EntComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntCommentMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *EntCommentMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetContent sets the "content" field.
func (m *EntCommentMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *EntCommentMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the EntComment entity.
// If the EntComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntCommentMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *EntCommentMutation) ClearContent() {
	m.content = nil
	m.clearedFields[entcomment.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *EntCommentMutation) ContentCleared() bool {
	_, ok := m.clearedFields[entcomment.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *EntCommentMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, entcomment.FieldContent)
}

// SetShare sets the "share" field.
func (m *EntCommentMutation) SetShare(e entcomment.Share) {
	m.share = &e
}

// Share returns the value of the "share" field in the mutation.
func (m *EntCommentMutation) Share() (r entcomment.Share, exists bool) {
	v := m.share
	if v == nil {
		return
	}
	return *v, true
}

// OldShare returns the old "share" field's value of the EntComment entity.
// If the EntComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntCommentMutation) OldShare(ctx context.Context) (v entcomment.Share, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShare is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShare requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShare: %w", err)
	}
	return oldValue.Share, nil
}

// ClearShare clears the value of the "share" field.
func (m *EntCommentMutation) ClearShare() {
	m.share = nil
	m.clearedFields[entcomment.FieldShare] = struct{}{}
}

// ShareCleared returns if the "share" field was cleared in this mutation.
func (m *EntCommentMutation) ShareCleared() bool {
	_, ok := m.clearedFields[entcomment.FieldShare]
	return ok
}

// ResetShare resets all changes to the "share" field.
func (m *EntCommentMutation) ResetShare() {
	m.share = nil
	delete(m.clearedFields, entcomment.FieldShare)
}

// SetBelongsToID sets the "belongsTo" edge to the EntPost entity by id.
func (m *EntCommentMutation) SetBelongsToID(id int) {
	m.belongsTo = &id
}

// ClearBelongsTo clears the "belongsTo" edge to the EntPost entity.
func (m *EntCommentMutation) ClearBelongsTo() {
	m.clearedbelongsTo = true
}

// BelongsToCleared reports if the "belongsTo" edge to the EntPost entity was cleared.
func (m *EntCommentMutation) BelongsToCleared() bool {
	return m.clearedbelongsTo
}

// BelongsToID returns the "belongsTo" edge ID in the mutation.
func (m *EntCommentMutation) BelongsToID() (id int, exists bool) {
	if m.belongsTo != nil {
		return *m.belongsTo, true
	}
	return
}

// BelongsToIDs returns the "belongsTo" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BelongsToID instead. It exists only for internal usage by the builders.
func (m *EntCommentMutation) BelongsToIDs() (ids []int) {
	if id := m.belongsTo; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBelongsTo resets all changes to the "belongsTo" edge.
func (m *EntCommentMutation) ResetBelongsTo() {
	m.belongsTo = nil
	m.clearedbelongsTo = false
}

// SetOwnedByID sets the "ownedBy" edge to the EntUser entity by id.
func (m *EntCommentMutation) SetOwnedByID(id int) {
	m.ownedBy = &id
}

// ClearOwnedBy clears the "ownedBy" edge to the EntUser entity.
func (m *EntCommentMutation) ClearOwnedBy() {
	m.clearedownedBy = true
}

// OwnedByCleared reports if the "ownedBy" edge to the EntUser entity was cleared.
func (m *EntCommentMutation) OwnedByCleared() bool {
	return m.clearedownedBy
}

// OwnedByID returns the "ownedBy" edge ID in the mutation.
func (m *EntCommentMutation) OwnedByID() (id int, exists bool) {
	if m.ownedBy != nil {
		return *m.ownedBy, true
	}
	return
}

// OwnedByIDs returns the "ownedBy" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnedByID instead. It exists only for internal usage by the builders.
func (m *EntCommentMutation) OwnedByIDs() (ids []int) {
	if id := m.ownedBy; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwnedBy resets all changes to the "ownedBy" edge.
func (m *EntCommentMutation) ResetOwnedBy() {
	m.ownedBy = nil
	m.clearedownedBy = false
}

// Where appends a list predicates to the EntCommentMutation builder.
func (m *EntCommentMutation) Where(ps ...predicate.EntComment) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EntCommentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (EntComment).
func (m *EntCommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EntCommentMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.timestamp != nil {
		fields = append(fields, entcomment.FieldTimestamp)
	}
	if m.content != nil {
		fields = append(fields, entcomment.FieldContent)
	}
	if m.share != nil {
		fields = append(fields, entcomment.FieldShare)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EntCommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entcomment.FieldTimestamp:
		return m.Timestamp()
	case entcomment.FieldContent:
		return m.Content()
	case entcomment.FieldShare:
		return m.Share()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EntCommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entcomment.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case entcomment.FieldContent:
		return m.OldContent(ctx)
	case entcomment.FieldShare:
		return m.OldShare(ctx)
	}
	return nil, fmt.Errorf("unknown EntComment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntCommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entcomment.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case entcomment.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case entcomment.FieldShare:
		v, ok := value.(entcomment.Share)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShare(v)
		return nil
	}
	return fmt.Errorf("unknown EntComment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EntCommentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EntCommentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntCommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EntComment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EntCommentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(entcomment.FieldContent) {
		fields = append(fields, entcomment.FieldContent)
	}
	if m.FieldCleared(entcomment.FieldShare) {
		fields = append(fields, entcomment.FieldShare)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EntCommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntCommentMutation) ClearField(name string) error {
	switch name {
	case entcomment.FieldContent:
		m.ClearContent()
		return nil
	case entcomment.FieldShare:
		m.ClearShare()
		return nil
	}
	return fmt.Errorf("unknown EntComment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EntCommentMutation) ResetField(name string) error {
	switch name {
	case entcomment.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case entcomment.FieldContent:
		m.ResetContent()
		return nil
	case entcomment.FieldShare:
		m.ResetShare()
		return nil
	}
	return fmt.Errorf("unknown EntComment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EntCommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.belongsTo != nil {
		edges = append(edges, entcomment.EdgeBelongsTo)
	}
	if m.ownedBy != nil {
		edges = append(edges, entcomment.EdgeOwnedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EntCommentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case entcomment.EdgeBelongsTo:
		if id := m.belongsTo; id != nil {
			return []ent.Value{*id}
		}
	case entcomment.EdgeOwnedBy:
		if id := m.ownedBy; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EntCommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EntCommentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EntCommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbelongsTo {
		edges = append(edges, entcomment.EdgeBelongsTo)
	}
	if m.clearedownedBy {
		edges = append(edges, entcomment.EdgeOwnedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EntCommentMutation) EdgeCleared(name string) bool {
	switch name {
	case entcomment.EdgeBelongsTo:
		return m.clearedbelongsTo
	case entcomment.EdgeOwnedBy:
		return m.clearedownedBy
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EntCommentMutation) ClearEdge(name string) error {
	switch name {
	case entcomment.EdgeBelongsTo:
		m.ClearBelongsTo()
		return nil
	case entcomment.EdgeOwnedBy:
		m.ClearOwnedBy()
		return nil
	}
	return fmt.Errorf("unknown EntComment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EntCommentMutation) ResetEdge(name string) error {
	switch name {
	case entcomment.EdgeBelongsTo:
		m.ResetBelongsTo()
		return nil
	case entcomment.EdgeOwnedBy:
		m.ResetOwnedBy()
		return nil
	}
	return fmt.Errorf("unknown EntComment edge %s", name)
}

// EntCourseMutation represents an operation that mutates the EntCourse nodes in the graph.
type EntCourseMutation struct {
	config
	op                Op
	typ               string
	id                *int
	name              *string
	courseUrl         *string
	paymentMethod     *entcourse.PaymentMethod
	paymentAmount     *float64
	addpaymentAmount  *float64
	startDate         *time.Time
	endDate           *time.Time
	monday            *bool
	tuesday           *bool
	wednesday         *bool
	thursday          *bool
	friday            *bool
	saturday          *bool
	sunday            *bool
	clearedFields     map[string]struct{}
	todo              map[int]struct{}
	removedtodo       map[int]struct{}
	clearedtodo       bool
	attendance        map[int]struct{}
	removedattendance map[int]struct{}
	clearedattendance bool
	post              map[int]struct{}
	removedpost       map[int]struct{}
	clearedpost       bool
	ownedBy           map[int]struct{}
	removedownedBy    map[int]struct{}
	clearedownedBy    bool
	joinedBy          map[int]struct{}
	removedjoinedBy   map[int]struct{}
	clearedjoinedBy   bool
	done              bool
	oldValue          func(context.Context) (*EntCourse, error)
	predicates        []predicate.EntCourse
}

var _ ent.Mutation = (*EntCourseMutation)(nil)

// entcourseOption allows management of the mutation configuration using functional options.
type entcourseOption func(*EntCourseMutation)

// newEntCourseMutation creates new mutation for the EntCourse entity.
func newEntCourseMutation(c config, op Op, opts ...entcourseOption) *EntCourseMutation {
	m := &EntCourseMutation{
		config:        c,
		op:            op,
		typ:           TypeEntCourse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntCourseID sets the ID field of the mutation.
func withEntCourseID(id int) entcourseOption {
	return func(m *EntCourseMutation) {
		var (
			err   error
			once  sync.Once
			value *EntCourse
		)
		m.oldValue = func(ctx context.Context) (*EntCourse, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EntCourse.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntCourse sets the old EntCourse of the mutation.
func withEntCourse(node *EntCourse) entcourseOption {
	return func(m *EntCourseMutation) {
		m.oldValue = func(context.Context) (*EntCourse, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntCourseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntCourseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EntCourseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EntCourseMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EntCourse.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *EntCourseMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EntCourseMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the EntCourse entity.
// If the EntCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntCourseMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EntCourseMutation) ResetName() {
	m.name = nil
}

// SetCourseUrl sets the "courseUrl" field.
func (m *EntCourseMutation) SetCourseUrl(s string) {
	m.courseUrl = &s
}

// CourseUrl returns the value of the "courseUrl" field in the mutation.
func (m *EntCourseMutation) CourseUrl() (r string, exists bool) {
	v := m.courseUrl
	if v == nil {
		return
	}
	return *v, true
}

// OldCourseUrl returns the old "courseUrl" field's value of the EntCourse entity.
// If the EntCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntCourseMutation) OldCourseUrl(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCourseUrl is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCourseUrl requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourseUrl: %w", err)
	}
	return oldValue.CourseUrl, nil
}

// ClearCourseUrl clears the value of the "courseUrl" field.
func (m *EntCourseMutation) ClearCourseUrl() {
	m.courseUrl = nil
	m.clearedFields[entcourse.FieldCourseUrl] = struct{}{}
}

// CourseUrlCleared returns if the "courseUrl" field was cleared in this mutation.
func (m *EntCourseMutation) CourseUrlCleared() bool {
	_, ok := m.clearedFields[entcourse.FieldCourseUrl]
	return ok
}

// ResetCourseUrl resets all changes to the "courseUrl" field.
func (m *EntCourseMutation) ResetCourseUrl() {
	m.courseUrl = nil
	delete(m.clearedFields, entcourse.FieldCourseUrl)
}

// SetPaymentMethod sets the "paymentMethod" field.
func (m *EntCourseMutation) SetPaymentMethod(em entcourse.PaymentMethod) {
	m.paymentMethod = &em
}

// PaymentMethod returns the value of the "paymentMethod" field in the mutation.
func (m *EntCourseMutation) PaymentMethod() (r entcourse.PaymentMethod, exists bool) {
	v := m.paymentMethod
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentMethod returns the old "paymentMethod" field's value of the EntCourse entity.
// If the EntCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntCourseMutation) OldPaymentMethod(ctx context.Context) (v entcourse.PaymentMethod, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentMethod: %w", err)
	}
	return oldValue.PaymentMethod, nil
}

// ClearPaymentMethod clears the value of the "paymentMethod" field.
func (m *EntCourseMutation) ClearPaymentMethod() {
	m.paymentMethod = nil
	m.clearedFields[entcourse.FieldPaymentMethod] = struct{}{}
}

// PaymentMethodCleared returns if the "paymentMethod" field was cleared in this mutation.
func (m *EntCourseMutation) PaymentMethodCleared() bool {
	_, ok := m.clearedFields[entcourse.FieldPaymentMethod]
	return ok
}

// ResetPaymentMethod resets all changes to the "paymentMethod" field.
func (m *EntCourseMutation) ResetPaymentMethod() {
	m.paymentMethod = nil
	delete(m.clearedFields, entcourse.FieldPaymentMethod)
}

// SetPaymentAmount sets the "paymentAmount" field.
func (m *EntCourseMutation) SetPaymentAmount(f float64) {
	m.paymentAmount = &f
	m.addpaymentAmount = nil
}

// PaymentAmount returns the value of the "paymentAmount" field in the mutation.
func (m *EntCourseMutation) PaymentAmount() (r float64, exists bool) {
	v := m.paymentAmount
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentAmount returns the old "paymentAmount" field's value of the EntCourse entity.
// If the EntCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntCourseMutation) OldPaymentAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentAmount: %w", err)
	}
	return oldValue.PaymentAmount, nil
}

// AddPaymentAmount adds f to the "paymentAmount" field.
func (m *EntCourseMutation) AddPaymentAmount(f float64) {
	if m.addpaymentAmount != nil {
		*m.addpaymentAmount += f
	} else {
		m.addpaymentAmount = &f
	}
}

// AddedPaymentAmount returns the value that was added to the "paymentAmount" field in this mutation.
func (m *EntCourseMutation) AddedPaymentAmount() (r float64, exists bool) {
	v := m.addpaymentAmount
	if v == nil {
		return
	}
	return *v, true
}

// ClearPaymentAmount clears the value of the "paymentAmount" field.
func (m *EntCourseMutation) ClearPaymentAmount() {
	m.paymentAmount = nil
	m.addpaymentAmount = nil
	m.clearedFields[entcourse.FieldPaymentAmount] = struct{}{}
}

// PaymentAmountCleared returns if the "paymentAmount" field was cleared in this mutation.
func (m *EntCourseMutation) PaymentAmountCleared() bool {
	_, ok := m.clearedFields[entcourse.FieldPaymentAmount]
	return ok
}

// ResetPaymentAmount resets all changes to the "paymentAmount" field.
func (m *EntCourseMutation) ResetPaymentAmount() {
	m.paymentAmount = nil
	m.addpaymentAmount = nil
	delete(m.clearedFields, entcourse.FieldPaymentAmount)
}

// SetStartDate sets the "startDate" field.
func (m *EntCourseMutation) SetStartDate(t time.Time) {
	m.startDate = &t
}

// StartDate returns the value of the "startDate" field in the mutation.
func (m *EntCourseMutation) StartDate() (r time.Time, exists bool) {
	v := m.startDate
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "startDate" field's value of the EntCourse entity.
// If the EntCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntCourseMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ClearStartDate clears the value of the "startDate" field.
func (m *EntCourseMutation) ClearStartDate() {
	m.startDate = nil
	m.clearedFields[entcourse.FieldStartDate] = struct{}{}
}

// StartDateCleared returns if the "startDate" field was cleared in this mutation.
func (m *EntCourseMutation) StartDateCleared() bool {
	_, ok := m.clearedFields[entcourse.FieldStartDate]
	return ok
}

// ResetStartDate resets all changes to the "startDate" field.
func (m *EntCourseMutation) ResetStartDate() {
	m.startDate = nil
	delete(m.clearedFields, entcourse.FieldStartDate)
}

// SetEndDate sets the "endDate" field.
func (m *EntCourseMutation) SetEndDate(t time.Time) {
	m.endDate = &t
}

// EndDate returns the value of the "endDate" field in the mutation.
func (m *EntCourseMutation) EndDate() (r time.Time, exists bool) {
	v := m.endDate
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "endDate" field's value of the EntCourse entity.
// If the EntCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntCourseMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "endDate" field.
func (m *EntCourseMutation) ClearEndDate() {
	m.endDate = nil
	m.clearedFields[entcourse.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "endDate" field was cleared in this mutation.
func (m *EntCourseMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[entcourse.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "endDate" field.
func (m *EntCourseMutation) ResetEndDate() {
	m.endDate = nil
	delete(m.clearedFields, entcourse.FieldEndDate)
}

// SetMonday sets the "monday" field.
func (m *EntCourseMutation) SetMonday(b bool) {
	m.monday = &b
}

// Monday returns the value of the "monday" field in the mutation.
func (m *EntCourseMutation) Monday() (r bool, exists bool) {
	v := m.monday
	if v == nil {
		return
	}
	return *v, true
}

// OldMonday returns the old "monday" field's value of the EntCourse entity.
// If the EntCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntCourseMutation) OldMonday(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMonday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMonday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMonday: %w", err)
	}
	return oldValue.Monday, nil
}

// ClearMonday clears the value of the "monday" field.
func (m *EntCourseMutation) ClearMonday() {
	m.monday = nil
	m.clearedFields[entcourse.FieldMonday] = struct{}{}
}

// MondayCleared returns if the "monday" field was cleared in this mutation.
func (m *EntCourseMutation) MondayCleared() bool {
	_, ok := m.clearedFields[entcourse.FieldMonday]
	return ok
}

// ResetMonday resets all changes to the "monday" field.
func (m *EntCourseMutation) ResetMonday() {
	m.monday = nil
	delete(m.clearedFields, entcourse.FieldMonday)
}

// SetTuesday sets the "tuesday" field.
func (m *EntCourseMutation) SetTuesday(b bool) {
	m.tuesday = &b
}

// Tuesday returns the value of the "tuesday" field in the mutation.
func (m *EntCourseMutation) Tuesday() (r bool, exists bool) {
	v := m.tuesday
	if v == nil {
		return
	}
	return *v, true
}

// OldTuesday returns the old "tuesday" field's value of the EntCourse entity.
// If the EntCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntCourseMutation) OldTuesday(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTuesday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTuesday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTuesday: %w", err)
	}
	return oldValue.Tuesday, nil
}

// ClearTuesday clears the value of the "tuesday" field.
func (m *EntCourseMutation) ClearTuesday() {
	m.tuesday = nil
	m.clearedFields[entcourse.FieldTuesday] = struct{}{}
}

// TuesdayCleared returns if the "tuesday" field was cleared in this mutation.
func (m *EntCourseMutation) TuesdayCleared() bool {
	_, ok := m.clearedFields[entcourse.FieldTuesday]
	return ok
}

// ResetTuesday resets all changes to the "tuesday" field.
func (m *EntCourseMutation) ResetTuesday() {
	m.tuesday = nil
	delete(m.clearedFields, entcourse.FieldTuesday)
}

// SetWednesday sets the "wednesday" field.
func (m *EntCourseMutation) SetWednesday(b bool) {
	m.wednesday = &b
}

// Wednesday returns the value of the "wednesday" field in the mutation.
func (m *EntCourseMutation) Wednesday() (r bool, exists bool) {
	v := m.wednesday
	if v == nil {
		return
	}
	return *v, true
}

// OldWednesday returns the old "wednesday" field's value of the EntCourse entity.
// If the EntCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntCourseMutation) OldWednesday(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWednesday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWednesday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWednesday: %w", err)
	}
	return oldValue.Wednesday, nil
}

// ClearWednesday clears the value of the "wednesday" field.
func (m *EntCourseMutation) ClearWednesday() {
	m.wednesday = nil
	m.clearedFields[entcourse.FieldWednesday] = struct{}{}
}

// WednesdayCleared returns if the "wednesday" field was cleared in this mutation.
func (m *EntCourseMutation) WednesdayCleared() bool {
	_, ok := m.clearedFields[entcourse.FieldWednesday]
	return ok
}

// ResetWednesday resets all changes to the "wednesday" field.
func (m *EntCourseMutation) ResetWednesday() {
	m.wednesday = nil
	delete(m.clearedFields, entcourse.FieldWednesday)
}

// SetThursday sets the "thursday" field.
func (m *EntCourseMutation) SetThursday(b bool) {
	m.thursday = &b
}

// Thursday returns the value of the "thursday" field in the mutation.
func (m *EntCourseMutation) Thursday() (r bool, exists bool) {
	v := m.thursday
	if v == nil {
		return
	}
	return *v, true
}

// OldThursday returns the old "thursday" field's value of the EntCourse entity.
// If the EntCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntCourseMutation) OldThursday(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThursday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThursday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThursday: %w", err)
	}
	return oldValue.Thursday, nil
}

// ClearThursday clears the value of the "thursday" field.
func (m *EntCourseMutation) ClearThursday() {
	m.thursday = nil
	m.clearedFields[entcourse.FieldThursday] = struct{}{}
}

// ThursdayCleared returns if the "thursday" field was cleared in this mutation.
func (m *EntCourseMutation) ThursdayCleared() bool {
	_, ok := m.clearedFields[entcourse.FieldThursday]
	return ok
}

// ResetThursday resets all changes to the "thursday" field.
func (m *EntCourseMutation) ResetThursday() {
	m.thursday = nil
	delete(m.clearedFields, entcourse.FieldThursday)
}

// SetFriday sets the "friday" field.
func (m *EntCourseMutation) SetFriday(b bool) {
	m.friday = &b
}

// Friday returns the value of the "friday" field in the mutation.
func (m *EntCourseMutation) Friday() (r bool, exists bool) {
	v := m.friday
	if v == nil {
		return
	}
	return *v, true
}

// OldFriday returns the old "friday" field's value of the EntCourse entity.
// If the EntCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntCourseMutation) OldFriday(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFriday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFriday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFriday: %w", err)
	}
	return oldValue.Friday, nil
}

// ClearFriday clears the value of the "friday" field.
func (m *EntCourseMutation) ClearFriday() {
	m.friday = nil
	m.clearedFields[entcourse.FieldFriday] = struct{}{}
}

// FridayCleared returns if the "friday" field was cleared in this mutation.
func (m *EntCourseMutation) FridayCleared() bool {
	_, ok := m.clearedFields[entcourse.FieldFriday]
	return ok
}

// ResetFriday resets all changes to the "friday" field.
func (m *EntCourseMutation) ResetFriday() {
	m.friday = nil
	delete(m.clearedFields, entcourse.FieldFriday)
}

// SetSaturday sets the "saturday" field.
func (m *EntCourseMutation) SetSaturday(b bool) {
	m.saturday = &b
}

// Saturday returns the value of the "saturday" field in the mutation.
func (m *EntCourseMutation) Saturday() (r bool, exists bool) {
	v := m.saturday
	if v == nil {
		return
	}
	return *v, true
}

// OldSaturday returns the old "saturday" field's value of the EntCourse entity.
// If the EntCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntCourseMutation) OldSaturday(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSaturday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSaturday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSaturday: %w", err)
	}
	return oldValue.Saturday, nil
}

// ClearSaturday clears the value of the "saturday" field.
func (m *EntCourseMutation) ClearSaturday() {
	m.saturday = nil
	m.clearedFields[entcourse.FieldSaturday] = struct{}{}
}

// SaturdayCleared returns if the "saturday" field was cleared in this mutation.
func (m *EntCourseMutation) SaturdayCleared() bool {
	_, ok := m.clearedFields[entcourse.FieldSaturday]
	return ok
}

// ResetSaturday resets all changes to the "saturday" field.
func (m *EntCourseMutation) ResetSaturday() {
	m.saturday = nil
	delete(m.clearedFields, entcourse.FieldSaturday)
}

// SetSunday sets the "sunday" field.
func (m *EntCourseMutation) SetSunday(b bool) {
	m.sunday = &b
}

// Sunday returns the value of the "sunday" field in the mutation.
func (m *EntCourseMutation) Sunday() (r bool, exists bool) {
	v := m.sunday
	if v == nil {
		return
	}
	return *v, true
}

// OldSunday returns the old "sunday" field's value of the EntCourse entity.
// If the EntCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntCourseMutation) OldSunday(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSunday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSunday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSunday: %w", err)
	}
	return oldValue.Sunday, nil
}

// ClearSunday clears the value of the "sunday" field.
func (m *EntCourseMutation) ClearSunday() {
	m.sunday = nil
	m.clearedFields[entcourse.FieldSunday] = struct{}{}
}

// SundayCleared returns if the "sunday" field was cleared in this mutation.
func (m *EntCourseMutation) SundayCleared() bool {
	_, ok := m.clearedFields[entcourse.FieldSunday]
	return ok
}

// ResetSunday resets all changes to the "sunday" field.
func (m *EntCourseMutation) ResetSunday() {
	m.sunday = nil
	delete(m.clearedFields, entcourse.FieldSunday)
}

// AddTodoIDs adds the "todo" edge to the EntTodo entity by ids.
func (m *EntCourseMutation) AddTodoIDs(ids ...int) {
	if m.todo == nil {
		m.todo = make(map[int]struct{})
	}
	for i := range ids {
		m.todo[ids[i]] = struct{}{}
	}
}

// ClearTodo clears the "todo" edge to the EntTodo entity.
func (m *EntCourseMutation) ClearTodo() {
	m.clearedtodo = true
}

// TodoCleared reports if the "todo" edge to the EntTodo entity was cleared.
func (m *EntCourseMutation) TodoCleared() bool {
	return m.clearedtodo
}

// RemoveTodoIDs removes the "todo" edge to the EntTodo entity by IDs.
func (m *EntCourseMutation) RemoveTodoIDs(ids ...int) {
	if m.removedtodo == nil {
		m.removedtodo = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.todo, ids[i])
		m.removedtodo[ids[i]] = struct{}{}
	}
}

// RemovedTodo returns the removed IDs of the "todo" edge to the EntTodo entity.
func (m *EntCourseMutation) RemovedTodoIDs() (ids []int) {
	for id := range m.removedtodo {
		ids = append(ids, id)
	}
	return
}

// TodoIDs returns the "todo" edge IDs in the mutation.
func (m *EntCourseMutation) TodoIDs() (ids []int) {
	for id := range m.todo {
		ids = append(ids, id)
	}
	return
}

// ResetTodo resets all changes to the "todo" edge.
func (m *EntCourseMutation) ResetTodo() {
	m.todo = nil
	m.clearedtodo = false
	m.removedtodo = nil
}

// AddAttendanceIDs adds the "attendance" edge to the EntAttendance entity by ids.
func (m *EntCourseMutation) AddAttendanceIDs(ids ...int) {
	if m.attendance == nil {
		m.attendance = make(map[int]struct{})
	}
	for i := range ids {
		m.attendance[ids[i]] = struct{}{}
	}
}

// ClearAttendance clears the "attendance" edge to the EntAttendance entity.
func (m *EntCourseMutation) ClearAttendance() {
	m.clearedattendance = true
}

// AttendanceCleared reports if the "attendance" edge to the EntAttendance entity was cleared.
func (m *EntCourseMutation) AttendanceCleared() bool {
	return m.clearedattendance
}

// RemoveAttendanceIDs removes the "attendance" edge to the EntAttendance entity by IDs.
func (m *EntCourseMutation) RemoveAttendanceIDs(ids ...int) {
	if m.removedattendance == nil {
		m.removedattendance = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.attendance, ids[i])
		m.removedattendance[ids[i]] = struct{}{}
	}
}

// RemovedAttendance returns the removed IDs of the "attendance" edge to the EntAttendance entity.
func (m *EntCourseMutation) RemovedAttendanceIDs() (ids []int) {
	for id := range m.removedattendance {
		ids = append(ids, id)
	}
	return
}

// AttendanceIDs returns the "attendance" edge IDs in the mutation.
func (m *EntCourseMutation) AttendanceIDs() (ids []int) {
	for id := range m.attendance {
		ids = append(ids, id)
	}
	return
}

// ResetAttendance resets all changes to the "attendance" edge.
func (m *EntCourseMutation) ResetAttendance() {
	m.attendance = nil
	m.clearedattendance = false
	m.removedattendance = nil
}

// AddPostIDs adds the "post" edge to the EntPost entity by ids.
func (m *EntCourseMutation) AddPostIDs(ids ...int) {
	if m.post == nil {
		m.post = make(map[int]struct{})
	}
	for i := range ids {
		m.post[ids[i]] = struct{}{}
	}
}

// ClearPost clears the "post" edge to the EntPost entity.
func (m *EntCourseMutation) ClearPost() {
	m.clearedpost = true
}

// PostCleared reports if the "post" edge to the EntPost entity was cleared.
func (m *EntCourseMutation) PostCleared() bool {
	return m.clearedpost
}

// RemovePostIDs removes the "post" edge to the EntPost entity by IDs.
func (m *EntCourseMutation) RemovePostIDs(ids ...int) {
	if m.removedpost == nil {
		m.removedpost = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.post, ids[i])
		m.removedpost[ids[i]] = struct{}{}
	}
}

// RemovedPost returns the removed IDs of the "post" edge to the EntPost entity.
func (m *EntCourseMutation) RemovedPostIDs() (ids []int) {
	for id := range m.removedpost {
		ids = append(ids, id)
	}
	return
}

// PostIDs returns the "post" edge IDs in the mutation.
func (m *EntCourseMutation) PostIDs() (ids []int) {
	for id := range m.post {
		ids = append(ids, id)
	}
	return
}

// ResetPost resets all changes to the "post" edge.
func (m *EntCourseMutation) ResetPost() {
	m.post = nil
	m.clearedpost = false
	m.removedpost = nil
}

// AddOwnedByIDs adds the "ownedBy" edge to the EntUser entity by ids.
func (m *EntCourseMutation) AddOwnedByIDs(ids ...int) {
	if m.ownedBy == nil {
		m.ownedBy = make(map[int]struct{})
	}
	for i := range ids {
		m.ownedBy[ids[i]] = struct{}{}
	}
}

// ClearOwnedBy clears the "ownedBy" edge to the EntUser entity.
func (m *EntCourseMutation) ClearOwnedBy() {
	m.clearedownedBy = true
}

// OwnedByCleared reports if the "ownedBy" edge to the EntUser entity was cleared.
func (m *EntCourseMutation) OwnedByCleared() bool {
	return m.clearedownedBy
}

// RemoveOwnedByIDs removes the "ownedBy" edge to the EntUser entity by IDs.
func (m *EntCourseMutation) RemoveOwnedByIDs(ids ...int) {
	if m.removedownedBy == nil {
		m.removedownedBy = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ownedBy, ids[i])
		m.removedownedBy[ids[i]] = struct{}{}
	}
}

// RemovedOwnedBy returns the removed IDs of the "ownedBy" edge to the EntUser entity.
func (m *EntCourseMutation) RemovedOwnedByIDs() (ids []int) {
	for id := range m.removedownedBy {
		ids = append(ids, id)
	}
	return
}

// OwnedByIDs returns the "ownedBy" edge IDs in the mutation.
func (m *EntCourseMutation) OwnedByIDs() (ids []int) {
	for id := range m.ownedBy {
		ids = append(ids, id)
	}
	return
}

// ResetOwnedBy resets all changes to the "ownedBy" edge.
func (m *EntCourseMutation) ResetOwnedBy() {
	m.ownedBy = nil
	m.clearedownedBy = false
	m.removedownedBy = nil
}

// AddJoinedByIDs adds the "joinedBy" edge to the EntUser entity by ids.
func (m *EntCourseMutation) AddJoinedByIDs(ids ...int) {
	if m.joinedBy == nil {
		m.joinedBy = make(map[int]struct{})
	}
	for i := range ids {
		m.joinedBy[ids[i]] = struct{}{}
	}
}

// ClearJoinedBy clears the "joinedBy" edge to the EntUser entity.
func (m *EntCourseMutation) ClearJoinedBy() {
	m.clearedjoinedBy = true
}

// JoinedByCleared reports if the "joinedBy" edge to the EntUser entity was cleared.
func (m *EntCourseMutation) JoinedByCleared() bool {
	return m.clearedjoinedBy
}

// RemoveJoinedByIDs removes the "joinedBy" edge to the EntUser entity by IDs.
func (m *EntCourseMutation) RemoveJoinedByIDs(ids ...int) {
	if m.removedjoinedBy == nil {
		m.removedjoinedBy = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.joinedBy, ids[i])
		m.removedjoinedBy[ids[i]] = struct{}{}
	}
}

// RemovedJoinedBy returns the removed IDs of the "joinedBy" edge to the EntUser entity.
func (m *EntCourseMutation) RemovedJoinedByIDs() (ids []int) {
	for id := range m.removedjoinedBy {
		ids = append(ids, id)
	}
	return
}

// JoinedByIDs returns the "joinedBy" edge IDs in the mutation.
func (m *EntCourseMutation) JoinedByIDs() (ids []int) {
	for id := range m.joinedBy {
		ids = append(ids, id)
	}
	return
}

// ResetJoinedBy resets all changes to the "joinedBy" edge.
func (m *EntCourseMutation) ResetJoinedBy() {
	m.joinedBy = nil
	m.clearedjoinedBy = false
	m.removedjoinedBy = nil
}

// Where appends a list predicates to the EntCourseMutation builder.
func (m *EntCourseMutation) Where(ps ...predicate.EntCourse) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EntCourseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (EntCourse).
func (m *EntCourseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EntCourseMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.name != nil {
		fields = append(fields, entcourse.FieldName)
	}
	if m.courseUrl != nil {
		fields = append(fields, entcourse.FieldCourseUrl)
	}
	if m.paymentMethod != nil {
		fields = append(fields, entcourse.FieldPaymentMethod)
	}
	if m.paymentAmount != nil {
		fields = append(fields, entcourse.FieldPaymentAmount)
	}
	if m.startDate != nil {
		fields = append(fields, entcourse.FieldStartDate)
	}
	if m.endDate != nil {
		fields = append(fields, entcourse.FieldEndDate)
	}
	if m.monday != nil {
		fields = append(fields, entcourse.FieldMonday)
	}
	if m.tuesday != nil {
		fields = append(fields, entcourse.FieldTuesday)
	}
	if m.wednesday != nil {
		fields = append(fields, entcourse.FieldWednesday)
	}
	if m.thursday != nil {
		fields = append(fields, entcourse.FieldThursday)
	}
	if m.friday != nil {
		fields = append(fields, entcourse.FieldFriday)
	}
	if m.saturday != nil {
		fields = append(fields, entcourse.FieldSaturday)
	}
	if m.sunday != nil {
		fields = append(fields, entcourse.FieldSunday)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EntCourseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entcourse.FieldName:
		return m.Name()
	case entcourse.FieldCourseUrl:
		return m.CourseUrl()
	case entcourse.FieldPaymentMethod:
		return m.PaymentMethod()
	case entcourse.FieldPaymentAmount:
		return m.PaymentAmount()
	case entcourse.FieldStartDate:
		return m.StartDate()
	case entcourse.FieldEndDate:
		return m.EndDate()
	case entcourse.FieldMonday:
		return m.Monday()
	case entcourse.FieldTuesday:
		return m.Tuesday()
	case entcourse.FieldWednesday:
		return m.Wednesday()
	case entcourse.FieldThursday:
		return m.Thursday()
	case entcourse.FieldFriday:
		return m.Friday()
	case entcourse.FieldSaturday:
		return m.Saturday()
	case entcourse.FieldSunday:
		return m.Sunday()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EntCourseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entcourse.FieldName:
		return m.OldName(ctx)
	case entcourse.FieldCourseUrl:
		return m.OldCourseUrl(ctx)
	case entcourse.FieldPaymentMethod:
		return m.OldPaymentMethod(ctx)
	case entcourse.FieldPaymentAmount:
		return m.OldPaymentAmount(ctx)
	case entcourse.FieldStartDate:
		return m.OldStartDate(ctx)
	case entcourse.FieldEndDate:
		return m.OldEndDate(ctx)
	case entcourse.FieldMonday:
		return m.OldMonday(ctx)
	case entcourse.FieldTuesday:
		return m.OldTuesday(ctx)
	case entcourse.FieldWednesday:
		return m.OldWednesday(ctx)
	case entcourse.FieldThursday:
		return m.OldThursday(ctx)
	case entcourse.FieldFriday:
		return m.OldFriday(ctx)
	case entcourse.FieldSaturday:
		return m.OldSaturday(ctx)
	case entcourse.FieldSunday:
		return m.OldSunday(ctx)
	}
	return nil, fmt.Errorf("unknown EntCourse field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntCourseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entcourse.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case entcourse.FieldCourseUrl:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourseUrl(v)
		return nil
	case entcourse.FieldPaymentMethod:
		v, ok := value.(entcourse.PaymentMethod)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentMethod(v)
		return nil
	case entcourse.FieldPaymentAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentAmount(v)
		return nil
	case entcourse.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case entcourse.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case entcourse.FieldMonday:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMonday(v)
		return nil
	case entcourse.FieldTuesday:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTuesday(v)
		return nil
	case entcourse.FieldWednesday:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWednesday(v)
		return nil
	case entcourse.FieldThursday:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThursday(v)
		return nil
	case entcourse.FieldFriday:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFriday(v)
		return nil
	case entcourse.FieldSaturday:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSaturday(v)
		return nil
	case entcourse.FieldSunday:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSunday(v)
		return nil
	}
	return fmt.Errorf("unknown EntCourse field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EntCourseMutation) AddedFields() []string {
	var fields []string
	if m.addpaymentAmount != nil {
		fields = append(fields, entcourse.FieldPaymentAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EntCourseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case entcourse.FieldPaymentAmount:
		return m.AddedPaymentAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntCourseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case entcourse.FieldPaymentAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPaymentAmount(v)
		return nil
	}
	return fmt.Errorf("unknown EntCourse numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EntCourseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(entcourse.FieldCourseUrl) {
		fields = append(fields, entcourse.FieldCourseUrl)
	}
	if m.FieldCleared(entcourse.FieldPaymentMethod) {
		fields = append(fields, entcourse.FieldPaymentMethod)
	}
	if m.FieldCleared(entcourse.FieldPaymentAmount) {
		fields = append(fields, entcourse.FieldPaymentAmount)
	}
	if m.FieldCleared(entcourse.FieldStartDate) {
		fields = append(fields, entcourse.FieldStartDate)
	}
	if m.FieldCleared(entcourse.FieldEndDate) {
		fields = append(fields, entcourse.FieldEndDate)
	}
	if m.FieldCleared(entcourse.FieldMonday) {
		fields = append(fields, entcourse.FieldMonday)
	}
	if m.FieldCleared(entcourse.FieldTuesday) {
		fields = append(fields, entcourse.FieldTuesday)
	}
	if m.FieldCleared(entcourse.FieldWednesday) {
		fields = append(fields, entcourse.FieldWednesday)
	}
	if m.FieldCleared(entcourse.FieldThursday) {
		fields = append(fields, entcourse.FieldThursday)
	}
	if m.FieldCleared(entcourse.FieldFriday) {
		fields = append(fields, entcourse.FieldFriday)
	}
	if m.FieldCleared(entcourse.FieldSaturday) {
		fields = append(fields, entcourse.FieldSaturday)
	}
	if m.FieldCleared(entcourse.FieldSunday) {
		fields = append(fields, entcourse.FieldSunday)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EntCourseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntCourseMutation) ClearField(name string) error {
	switch name {
	case entcourse.FieldCourseUrl:
		m.ClearCourseUrl()
		return nil
	case entcourse.FieldPaymentMethod:
		m.ClearPaymentMethod()
		return nil
	case entcourse.FieldPaymentAmount:
		m.ClearPaymentAmount()
		return nil
	case entcourse.FieldStartDate:
		m.ClearStartDate()
		return nil
	case entcourse.FieldEndDate:
		m.ClearEndDate()
		return nil
	case entcourse.FieldMonday:
		m.ClearMonday()
		return nil
	case entcourse.FieldTuesday:
		m.ClearTuesday()
		return nil
	case entcourse.FieldWednesday:
		m.ClearWednesday()
		return nil
	case entcourse.FieldThursday:
		m.ClearThursday()
		return nil
	case entcourse.FieldFriday:
		m.ClearFriday()
		return nil
	case entcourse.FieldSaturday:
		m.ClearSaturday()
		return nil
	case entcourse.FieldSunday:
		m.ClearSunday()
		return nil
	}
	return fmt.Errorf("unknown EntCourse nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EntCourseMutation) ResetField(name string) error {
	switch name {
	case entcourse.FieldName:
		m.ResetName()
		return nil
	case entcourse.FieldCourseUrl:
		m.ResetCourseUrl()
		return nil
	case entcourse.FieldPaymentMethod:
		m.ResetPaymentMethod()
		return nil
	case entcourse.FieldPaymentAmount:
		m.ResetPaymentAmount()
		return nil
	case entcourse.FieldStartDate:
		m.ResetStartDate()
		return nil
	case entcourse.FieldEndDate:
		m.ResetEndDate()
		return nil
	case entcourse.FieldMonday:
		m.ResetMonday()
		return nil
	case entcourse.FieldTuesday:
		m.ResetTuesday()
		return nil
	case entcourse.FieldWednesday:
		m.ResetWednesday()
		return nil
	case entcourse.FieldThursday:
		m.ResetThursday()
		return nil
	case entcourse.FieldFriday:
		m.ResetFriday()
		return nil
	case entcourse.FieldSaturday:
		m.ResetSaturday()
		return nil
	case entcourse.FieldSunday:
		m.ResetSunday()
		return nil
	}
	return fmt.Errorf("unknown EntCourse field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EntCourseMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.todo != nil {
		edges = append(edges, entcourse.EdgeTodo)
	}
	if m.attendance != nil {
		edges = append(edges, entcourse.EdgeAttendance)
	}
	if m.post != nil {
		edges = append(edges, entcourse.EdgePost)
	}
	if m.ownedBy != nil {
		edges = append(edges, entcourse.EdgeOwnedBy)
	}
	if m.joinedBy != nil {
		edges = append(edges, entcourse.EdgeJoinedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EntCourseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case entcourse.EdgeTodo:
		ids := make([]ent.Value, 0, len(m.todo))
		for id := range m.todo {
			ids = append(ids, id)
		}
		return ids
	case entcourse.EdgeAttendance:
		ids := make([]ent.Value, 0, len(m.attendance))
		for id := range m.attendance {
			ids = append(ids, id)
		}
		return ids
	case entcourse.EdgePost:
		ids := make([]ent.Value, 0, len(m.post))
		for id := range m.post {
			ids = append(ids, id)
		}
		return ids
	case entcourse.EdgeOwnedBy:
		ids := make([]ent.Value, 0, len(m.ownedBy))
		for id := range m.ownedBy {
			ids = append(ids, id)
		}
		return ids
	case entcourse.EdgeJoinedBy:
		ids := make([]ent.Value, 0, len(m.joinedBy))
		for id := range m.joinedBy {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EntCourseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedtodo != nil {
		edges = append(edges, entcourse.EdgeTodo)
	}
	if m.removedattendance != nil {
		edges = append(edges, entcourse.EdgeAttendance)
	}
	if m.removedpost != nil {
		edges = append(edges, entcourse.EdgePost)
	}
	if m.removedownedBy != nil {
		edges = append(edges, entcourse.EdgeOwnedBy)
	}
	if m.removedjoinedBy != nil {
		edges = append(edges, entcourse.EdgeJoinedBy)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EntCourseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case entcourse.EdgeTodo:
		ids := make([]ent.Value, 0, len(m.removedtodo))
		for id := range m.removedtodo {
			ids = append(ids, id)
		}
		return ids
	case entcourse.EdgeAttendance:
		ids := make([]ent.Value, 0, len(m.removedattendance))
		for id := range m.removedattendance {
			ids = append(ids, id)
		}
		return ids
	case entcourse.EdgePost:
		ids := make([]ent.Value, 0, len(m.removedpost))
		for id := range m.removedpost {
			ids = append(ids, id)
		}
		return ids
	case entcourse.EdgeOwnedBy:
		ids := make([]ent.Value, 0, len(m.removedownedBy))
		for id := range m.removedownedBy {
			ids = append(ids, id)
		}
		return ids
	case entcourse.EdgeJoinedBy:
		ids := make([]ent.Value, 0, len(m.removedjoinedBy))
		for id := range m.removedjoinedBy {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EntCourseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedtodo {
		edges = append(edges, entcourse.EdgeTodo)
	}
	if m.clearedattendance {
		edges = append(edges, entcourse.EdgeAttendance)
	}
	if m.clearedpost {
		edges = append(edges, entcourse.EdgePost)
	}
	if m.clearedownedBy {
		edges = append(edges, entcourse.EdgeOwnedBy)
	}
	if m.clearedjoinedBy {
		edges = append(edges, entcourse.EdgeJoinedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EntCourseMutation) EdgeCleared(name string) bool {
	switch name {
	case entcourse.EdgeTodo:
		return m.clearedtodo
	case entcourse.EdgeAttendance:
		return m.clearedattendance
	case entcourse.EdgePost:
		return m.clearedpost
	case entcourse.EdgeOwnedBy:
		return m.clearedownedBy
	case entcourse.EdgeJoinedBy:
		return m.clearedjoinedBy
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EntCourseMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown EntCourse unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EntCourseMutation) ResetEdge(name string) error {
	switch name {
	case entcourse.EdgeTodo:
		m.ResetTodo()
		return nil
	case entcourse.EdgeAttendance:
		m.ResetAttendance()
		return nil
	case entcourse.EdgePost:
		m.ResetPost()
		return nil
	case entcourse.EdgeOwnedBy:
		m.ResetOwnedBy()
		return nil
	case entcourse.EdgeJoinedBy:
		m.ResetJoinedBy()
		return nil
	}
	return fmt.Errorf("unknown EntCourse edge %s", name)
}

// EntPostMutation represents an operation that mutates the EntPost nodes in the graph.
type EntPostMutation struct {
	config
	op               Op
	typ              string
	id               *int
	timestamp        *time.Time
	content          *string
	share            *entpost.Share
	clearedFields    map[string]struct{}
	comment          map[int]struct{}
	removedcomment   map[int]struct{}
	clearedcomment   bool
	shareWith        map[int]struct{}
	removedshareWith map[int]struct{}
	clearedshareWith bool
	belongsTo        *int
	clearedbelongsTo bool
	ownedBy          *int
	clearedownedBy   bool
	done             bool
	oldValue         func(context.Context) (*EntPost, error)
	predicates       []predicate.EntPost
}

var _ ent.Mutation = (*EntPostMutation)(nil)

// entpostOption allows management of the mutation configuration using functional options.
type entpostOption func(*EntPostMutation)

// newEntPostMutation creates new mutation for the EntPost entity.
func newEntPostMutation(c config, op Op, opts ...entpostOption) *EntPostMutation {
	m := &EntPostMutation{
		config:        c,
		op:            op,
		typ:           TypeEntPost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntPostID sets the ID field of the mutation.
func withEntPostID(id int) entpostOption {
	return func(m *EntPostMutation) {
		var (
			err   error
			once  sync.Once
			value *EntPost
		)
		m.oldValue = func(ctx context.Context) (*EntPost, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EntPost.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntPost sets the old EntPost of the mutation.
func withEntPost(node *EntPost) entpostOption {
	return func(m *EntPostMutation) {
		m.oldValue = func(context.Context) (*EntPost, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntPostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntPostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EntPostMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EntPostMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EntPost.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTimestamp sets the "timestamp" field.
func (m *EntPostMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *EntPostMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the EntPost entity.
// If the EntPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntPostMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *EntPostMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetContent sets the "content" field.
func (m *EntPostMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *EntPostMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the EntPost entity.
// If the EntPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntPostMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *EntPostMutation) ClearContent() {
	m.content = nil
	m.clearedFields[entpost.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *EntPostMutation) ContentCleared() bool {
	_, ok := m.clearedFields[entpost.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *EntPostMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, entpost.FieldContent)
}

// SetShare sets the "share" field.
func (m *EntPostMutation) SetShare(e entpost.Share) {
	m.share = &e
}

// Share returns the value of the "share" field in the mutation.
func (m *EntPostMutation) Share() (r entpost.Share, exists bool) {
	v := m.share
	if v == nil {
		return
	}
	return *v, true
}

// OldShare returns the old "share" field's value of the EntPost entity.
// If the EntPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntPostMutation) OldShare(ctx context.Context) (v entpost.Share, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShare is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShare requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShare: %w", err)
	}
	return oldValue.Share, nil
}

// ClearShare clears the value of the "share" field.
func (m *EntPostMutation) ClearShare() {
	m.share = nil
	m.clearedFields[entpost.FieldShare] = struct{}{}
}

// ShareCleared returns if the "share" field was cleared in this mutation.
func (m *EntPostMutation) ShareCleared() bool {
	_, ok := m.clearedFields[entpost.FieldShare]
	return ok
}

// ResetShare resets all changes to the "share" field.
func (m *EntPostMutation) ResetShare() {
	m.share = nil
	delete(m.clearedFields, entpost.FieldShare)
}

// AddCommentIDs adds the "comment" edge to the EntComment entity by ids.
func (m *EntPostMutation) AddCommentIDs(ids ...int) {
	if m.comment == nil {
		m.comment = make(map[int]struct{})
	}
	for i := range ids {
		m.comment[ids[i]] = struct{}{}
	}
}

// ClearComment clears the "comment" edge to the EntComment entity.
func (m *EntPostMutation) ClearComment() {
	m.clearedcomment = true
}

// CommentCleared reports if the "comment" edge to the EntComment entity was cleared.
func (m *EntPostMutation) CommentCleared() bool {
	return m.clearedcomment
}

// RemoveCommentIDs removes the "comment" edge to the EntComment entity by IDs.
func (m *EntPostMutation) RemoveCommentIDs(ids ...int) {
	if m.removedcomment == nil {
		m.removedcomment = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.comment, ids[i])
		m.removedcomment[ids[i]] = struct{}{}
	}
}

// RemovedComment returns the removed IDs of the "comment" edge to the EntComment entity.
func (m *EntPostMutation) RemovedCommentIDs() (ids []int) {
	for id := range m.removedcomment {
		ids = append(ids, id)
	}
	return
}

// CommentIDs returns the "comment" edge IDs in the mutation.
func (m *EntPostMutation) CommentIDs() (ids []int) {
	for id := range m.comment {
		ids = append(ids, id)
	}
	return
}

// ResetComment resets all changes to the "comment" edge.
func (m *EntPostMutation) ResetComment() {
	m.comment = nil
	m.clearedcomment = false
	m.removedcomment = nil
}

// AddShareWithIDs adds the "shareWith" edge to the EntUser entity by ids.
func (m *EntPostMutation) AddShareWithIDs(ids ...int) {
	if m.shareWith == nil {
		m.shareWith = make(map[int]struct{})
	}
	for i := range ids {
		m.shareWith[ids[i]] = struct{}{}
	}
}

// ClearShareWith clears the "shareWith" edge to the EntUser entity.
func (m *EntPostMutation) ClearShareWith() {
	m.clearedshareWith = true
}

// ShareWithCleared reports if the "shareWith" edge to the EntUser entity was cleared.
func (m *EntPostMutation) ShareWithCleared() bool {
	return m.clearedshareWith
}

// RemoveShareWithIDs removes the "shareWith" edge to the EntUser entity by IDs.
func (m *EntPostMutation) RemoveShareWithIDs(ids ...int) {
	if m.removedshareWith == nil {
		m.removedshareWith = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.shareWith, ids[i])
		m.removedshareWith[ids[i]] = struct{}{}
	}
}

// RemovedShareWith returns the removed IDs of the "shareWith" edge to the EntUser entity.
func (m *EntPostMutation) RemovedShareWithIDs() (ids []int) {
	for id := range m.removedshareWith {
		ids = append(ids, id)
	}
	return
}

// ShareWithIDs returns the "shareWith" edge IDs in the mutation.
func (m *EntPostMutation) ShareWithIDs() (ids []int) {
	for id := range m.shareWith {
		ids = append(ids, id)
	}
	return
}

// ResetShareWith resets all changes to the "shareWith" edge.
func (m *EntPostMutation) ResetShareWith() {
	m.shareWith = nil
	m.clearedshareWith = false
	m.removedshareWith = nil
}

// SetBelongsToID sets the "belongsTo" edge to the EntCourse entity by id.
func (m *EntPostMutation) SetBelongsToID(id int) {
	m.belongsTo = &id
}

// ClearBelongsTo clears the "belongsTo" edge to the EntCourse entity.
func (m *EntPostMutation) ClearBelongsTo() {
	m.clearedbelongsTo = true
}

// BelongsToCleared reports if the "belongsTo" edge to the EntCourse entity was cleared.
func (m *EntPostMutation) BelongsToCleared() bool {
	return m.clearedbelongsTo
}

// BelongsToID returns the "belongsTo" edge ID in the mutation.
func (m *EntPostMutation) BelongsToID() (id int, exists bool) {
	if m.belongsTo != nil {
		return *m.belongsTo, true
	}
	return
}

// BelongsToIDs returns the "belongsTo" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BelongsToID instead. It exists only for internal usage by the builders.
func (m *EntPostMutation) BelongsToIDs() (ids []int) {
	if id := m.belongsTo; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBelongsTo resets all changes to the "belongsTo" edge.
func (m *EntPostMutation) ResetBelongsTo() {
	m.belongsTo = nil
	m.clearedbelongsTo = false
}

// SetOwnedByID sets the "ownedBy" edge to the EntUser entity by id.
func (m *EntPostMutation) SetOwnedByID(id int) {
	m.ownedBy = &id
}

// ClearOwnedBy clears the "ownedBy" edge to the EntUser entity.
func (m *EntPostMutation) ClearOwnedBy() {
	m.clearedownedBy = true
}

// OwnedByCleared reports if the "ownedBy" edge to the EntUser entity was cleared.
func (m *EntPostMutation) OwnedByCleared() bool {
	return m.clearedownedBy
}

// OwnedByID returns the "ownedBy" edge ID in the mutation.
func (m *EntPostMutation) OwnedByID() (id int, exists bool) {
	if m.ownedBy != nil {
		return *m.ownedBy, true
	}
	return
}

// OwnedByIDs returns the "ownedBy" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnedByID instead. It exists only for internal usage by the builders.
func (m *EntPostMutation) OwnedByIDs() (ids []int) {
	if id := m.ownedBy; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwnedBy resets all changes to the "ownedBy" edge.
func (m *EntPostMutation) ResetOwnedBy() {
	m.ownedBy = nil
	m.clearedownedBy = false
}

// Where appends a list predicates to the EntPostMutation builder.
func (m *EntPostMutation) Where(ps ...predicate.EntPost) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EntPostMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (EntPost).
func (m *EntPostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EntPostMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.timestamp != nil {
		fields = append(fields, entpost.FieldTimestamp)
	}
	if m.content != nil {
		fields = append(fields, entpost.FieldContent)
	}
	if m.share != nil {
		fields = append(fields, entpost.FieldShare)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EntPostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entpost.FieldTimestamp:
		return m.Timestamp()
	case entpost.FieldContent:
		return m.Content()
	case entpost.FieldShare:
		return m.Share()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EntPostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entpost.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case entpost.FieldContent:
		return m.OldContent(ctx)
	case entpost.FieldShare:
		return m.OldShare(ctx)
	}
	return nil, fmt.Errorf("unknown EntPost field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntPostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entpost.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case entpost.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case entpost.FieldShare:
		v, ok := value.(entpost.Share)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShare(v)
		return nil
	}
	return fmt.Errorf("unknown EntPost field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EntPostMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EntPostMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntPostMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EntPost numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EntPostMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(entpost.FieldContent) {
		fields = append(fields, entpost.FieldContent)
	}
	if m.FieldCleared(entpost.FieldShare) {
		fields = append(fields, entpost.FieldShare)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EntPostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntPostMutation) ClearField(name string) error {
	switch name {
	case entpost.FieldContent:
		m.ClearContent()
		return nil
	case entpost.FieldShare:
		m.ClearShare()
		return nil
	}
	return fmt.Errorf("unknown EntPost nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EntPostMutation) ResetField(name string) error {
	switch name {
	case entpost.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case entpost.FieldContent:
		m.ResetContent()
		return nil
	case entpost.FieldShare:
		m.ResetShare()
		return nil
	}
	return fmt.Errorf("unknown EntPost field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EntPostMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.comment != nil {
		edges = append(edges, entpost.EdgeComment)
	}
	if m.shareWith != nil {
		edges = append(edges, entpost.EdgeShareWith)
	}
	if m.belongsTo != nil {
		edges = append(edges, entpost.EdgeBelongsTo)
	}
	if m.ownedBy != nil {
		edges = append(edges, entpost.EdgeOwnedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EntPostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case entpost.EdgeComment:
		ids := make([]ent.Value, 0, len(m.comment))
		for id := range m.comment {
			ids = append(ids, id)
		}
		return ids
	case entpost.EdgeShareWith:
		ids := make([]ent.Value, 0, len(m.shareWith))
		for id := range m.shareWith {
			ids = append(ids, id)
		}
		return ids
	case entpost.EdgeBelongsTo:
		if id := m.belongsTo; id != nil {
			return []ent.Value{*id}
		}
	case entpost.EdgeOwnedBy:
		if id := m.ownedBy; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EntPostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedcomment != nil {
		edges = append(edges, entpost.EdgeComment)
	}
	if m.removedshareWith != nil {
		edges = append(edges, entpost.EdgeShareWith)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EntPostMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case entpost.EdgeComment:
		ids := make([]ent.Value, 0, len(m.removedcomment))
		for id := range m.removedcomment {
			ids = append(ids, id)
		}
		return ids
	case entpost.EdgeShareWith:
		ids := make([]ent.Value, 0, len(m.removedshareWith))
		for id := range m.removedshareWith {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EntPostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcomment {
		edges = append(edges, entpost.EdgeComment)
	}
	if m.clearedshareWith {
		edges = append(edges, entpost.EdgeShareWith)
	}
	if m.clearedbelongsTo {
		edges = append(edges, entpost.EdgeBelongsTo)
	}
	if m.clearedownedBy {
		edges = append(edges, entpost.EdgeOwnedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EntPostMutation) EdgeCleared(name string) bool {
	switch name {
	case entpost.EdgeComment:
		return m.clearedcomment
	case entpost.EdgeShareWith:
		return m.clearedshareWith
	case entpost.EdgeBelongsTo:
		return m.clearedbelongsTo
	case entpost.EdgeOwnedBy:
		return m.clearedownedBy
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EntPostMutation) ClearEdge(name string) error {
	switch name {
	case entpost.EdgeBelongsTo:
		m.ClearBelongsTo()
		return nil
	case entpost.EdgeOwnedBy:
		m.ClearOwnedBy()
		return nil
	}
	return fmt.Errorf("unknown EntPost unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EntPostMutation) ResetEdge(name string) error {
	switch name {
	case entpost.EdgeComment:
		m.ResetComment()
		return nil
	case entpost.EdgeShareWith:
		m.ResetShareWith()
		return nil
	case entpost.EdgeBelongsTo:
		m.ResetBelongsTo()
		return nil
	case entpost.EdgeOwnedBy:
		m.ResetOwnedBy()
		return nil
	}
	return fmt.Errorf("unknown EntPost edge %s", name)
}

// EntTodoMutation represents an operation that mutates the EntTodo nodes in the graph.
type EntTodoMutation struct {
	config
	op             Op
	typ            string
	id             *int
	date           *time.Time
	startTime      *time.Time
	endTime        *time.Time
	day            *time.Time
	lesson         *string
	homework       *string
	status         *enttodo.Status
	clearedFields  map[string]struct{}
	todoFor        *int
	clearedtodoFor bool
	ownedBy        *int
	clearedownedBy bool
	done           bool
	oldValue       func(context.Context) (*EntTodo, error)
	predicates     []predicate.EntTodo
}

var _ ent.Mutation = (*EntTodoMutation)(nil)

// enttodoOption allows management of the mutation configuration using functional options.
type enttodoOption func(*EntTodoMutation)

// newEntTodoMutation creates new mutation for the EntTodo entity.
func newEntTodoMutation(c config, op Op, opts ...enttodoOption) *EntTodoMutation {
	m := &EntTodoMutation{
		config:        c,
		op:            op,
		typ:           TypeEntTodo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntTodoID sets the ID field of the mutation.
func withEntTodoID(id int) enttodoOption {
	return func(m *EntTodoMutation) {
		var (
			err   error
			once  sync.Once
			value *EntTodo
		)
		m.oldValue = func(ctx context.Context) (*EntTodo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EntTodo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntTodo sets the old EntTodo of the mutation.
func withEntTodo(node *EntTodo) enttodoOption {
	return func(m *EntTodoMutation) {
		m.oldValue = func(context.Context) (*EntTodo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntTodoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntTodoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EntTodoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EntTodoMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EntTodo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDate sets the "date" field.
func (m *EntTodoMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *EntTodoMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the EntTodo entity.
// If the EntTodo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntTodoMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *EntTodoMutation) ResetDate() {
	m.date = nil
}

// SetStartTime sets the "startTime" field.
func (m *EntTodoMutation) SetStartTime(t time.Time) {
	m.startTime = &t
}

// StartTime returns the value of the "startTime" field in the mutation.
func (m *EntTodoMutation) StartTime() (r time.Time, exists bool) {
	v := m.startTime
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "startTime" field's value of the EntTodo entity.
// If the EntTodo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntTodoMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ClearStartTime clears the value of the "startTime" field.
func (m *EntTodoMutation) ClearStartTime() {
	m.startTime = nil
	m.clearedFields[enttodo.FieldStartTime] = struct{}{}
}

// StartTimeCleared returns if the "startTime" field was cleared in this mutation.
func (m *EntTodoMutation) StartTimeCleared() bool {
	_, ok := m.clearedFields[enttodo.FieldStartTime]
	return ok
}

// ResetStartTime resets all changes to the "startTime" field.
func (m *EntTodoMutation) ResetStartTime() {
	m.startTime = nil
	delete(m.clearedFields, enttodo.FieldStartTime)
}

// SetEndTime sets the "endTime" field.
func (m *EntTodoMutation) SetEndTime(t time.Time) {
	m.endTime = &t
}

// EndTime returns the value of the "endTime" field in the mutation.
func (m *EntTodoMutation) EndTime() (r time.Time, exists bool) {
	v := m.endTime
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "endTime" field's value of the EntTodo entity.
// If the EntTodo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntTodoMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ClearEndTime clears the value of the "endTime" field.
func (m *EntTodoMutation) ClearEndTime() {
	m.endTime = nil
	m.clearedFields[enttodo.FieldEndTime] = struct{}{}
}

// EndTimeCleared returns if the "endTime" field was cleared in this mutation.
func (m *EntTodoMutation) EndTimeCleared() bool {
	_, ok := m.clearedFields[enttodo.FieldEndTime]
	return ok
}

// ResetEndTime resets all changes to the "endTime" field.
func (m *EntTodoMutation) ResetEndTime() {
	m.endTime = nil
	delete(m.clearedFields, enttodo.FieldEndTime)
}

// SetDay sets the "day" field.
func (m *EntTodoMutation) SetDay(t time.Time) {
	m.day = &t
}

// Day returns the value of the "day" field in the mutation.
func (m *EntTodoMutation) Day() (r time.Time, exists bool) {
	v := m.day
	if v == nil {
		return
	}
	return *v, true
}

// OldDay returns the old "day" field's value of the EntTodo entity.
// If the EntTodo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntTodoMutation) OldDay(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDay: %w", err)
	}
	return oldValue.Day, nil
}

// ClearDay clears the value of the "day" field.
func (m *EntTodoMutation) ClearDay() {
	m.day = nil
	m.clearedFields[enttodo.FieldDay] = struct{}{}
}

// DayCleared returns if the "day" field was cleared in this mutation.
func (m *EntTodoMutation) DayCleared() bool {
	_, ok := m.clearedFields[enttodo.FieldDay]
	return ok
}

// ResetDay resets all changes to the "day" field.
func (m *EntTodoMutation) ResetDay() {
	m.day = nil
	delete(m.clearedFields, enttodo.FieldDay)
}

// SetLesson sets the "lesson" field.
func (m *EntTodoMutation) SetLesson(s string) {
	m.lesson = &s
}

// Lesson returns the value of the "lesson" field in the mutation.
func (m *EntTodoMutation) Lesson() (r string, exists bool) {
	v := m.lesson
	if v == nil {
		return
	}
	return *v, true
}

// OldLesson returns the old "lesson" field's value of the EntTodo entity.
// If the EntTodo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntTodoMutation) OldLesson(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLesson is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLesson requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLesson: %w", err)
	}
	return oldValue.Lesson, nil
}

// ClearLesson clears the value of the "lesson" field.
func (m *EntTodoMutation) ClearLesson() {
	m.lesson = nil
	m.clearedFields[enttodo.FieldLesson] = struct{}{}
}

// LessonCleared returns if the "lesson" field was cleared in this mutation.
func (m *EntTodoMutation) LessonCleared() bool {
	_, ok := m.clearedFields[enttodo.FieldLesson]
	return ok
}

// ResetLesson resets all changes to the "lesson" field.
func (m *EntTodoMutation) ResetLesson() {
	m.lesson = nil
	delete(m.clearedFields, enttodo.FieldLesson)
}

// SetHomework sets the "homework" field.
func (m *EntTodoMutation) SetHomework(s string) {
	m.homework = &s
}

// Homework returns the value of the "homework" field in the mutation.
func (m *EntTodoMutation) Homework() (r string, exists bool) {
	v := m.homework
	if v == nil {
		return
	}
	return *v, true
}

// OldHomework returns the old "homework" field's value of the EntTodo entity.
// If the EntTodo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntTodoMutation) OldHomework(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHomework is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHomework requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHomework: %w", err)
	}
	return oldValue.Homework, nil
}

// ClearHomework clears the value of the "homework" field.
func (m *EntTodoMutation) ClearHomework() {
	m.homework = nil
	m.clearedFields[enttodo.FieldHomework] = struct{}{}
}

// HomeworkCleared returns if the "homework" field was cleared in this mutation.
func (m *EntTodoMutation) HomeworkCleared() bool {
	_, ok := m.clearedFields[enttodo.FieldHomework]
	return ok
}

// ResetHomework resets all changes to the "homework" field.
func (m *EntTodoMutation) ResetHomework() {
	m.homework = nil
	delete(m.clearedFields, enttodo.FieldHomework)
}

// SetStatus sets the "status" field.
func (m *EntTodoMutation) SetStatus(e enttodo.Status) {
	m.status = &e
}

// Status returns the value of the "status" field in the mutation.
func (m *EntTodoMutation) Status() (r enttodo.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the EntTodo entity.
// If the EntTodo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntTodoMutation) OldStatus(ctx context.Context) (v enttodo.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *EntTodoMutation) ResetStatus() {
	m.status = nil
}

// SetTodoForID sets the "todoFor" edge to the EntCourse entity by id.
func (m *EntTodoMutation) SetTodoForID(id int) {
	m.todoFor = &id
}

// ClearTodoFor clears the "todoFor" edge to the EntCourse entity.
func (m *EntTodoMutation) ClearTodoFor() {
	m.clearedtodoFor = true
}

// TodoForCleared reports if the "todoFor" edge to the EntCourse entity was cleared.
func (m *EntTodoMutation) TodoForCleared() bool {
	return m.clearedtodoFor
}

// TodoForID returns the "todoFor" edge ID in the mutation.
func (m *EntTodoMutation) TodoForID() (id int, exists bool) {
	if m.todoFor != nil {
		return *m.todoFor, true
	}
	return
}

// TodoForIDs returns the "todoFor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TodoForID instead. It exists only for internal usage by the builders.
func (m *EntTodoMutation) TodoForIDs() (ids []int) {
	if id := m.todoFor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTodoFor resets all changes to the "todoFor" edge.
func (m *EntTodoMutation) ResetTodoFor() {
	m.todoFor = nil
	m.clearedtodoFor = false
}

// SetOwnedByID sets the "ownedBy" edge to the EntUser entity by id.
func (m *EntTodoMutation) SetOwnedByID(id int) {
	m.ownedBy = &id
}

// ClearOwnedBy clears the "ownedBy" edge to the EntUser entity.
func (m *EntTodoMutation) ClearOwnedBy() {
	m.clearedownedBy = true
}

// OwnedByCleared reports if the "ownedBy" edge to the EntUser entity was cleared.
func (m *EntTodoMutation) OwnedByCleared() bool {
	return m.clearedownedBy
}

// OwnedByID returns the "ownedBy" edge ID in the mutation.
func (m *EntTodoMutation) OwnedByID() (id int, exists bool) {
	if m.ownedBy != nil {
		return *m.ownedBy, true
	}
	return
}

// OwnedByIDs returns the "ownedBy" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnedByID instead. It exists only for internal usage by the builders.
func (m *EntTodoMutation) OwnedByIDs() (ids []int) {
	if id := m.ownedBy; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwnedBy resets all changes to the "ownedBy" edge.
func (m *EntTodoMutation) ResetOwnedBy() {
	m.ownedBy = nil
	m.clearedownedBy = false
}

// Where appends a list predicates to the EntTodoMutation builder.
func (m *EntTodoMutation) Where(ps ...predicate.EntTodo) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EntTodoMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (EntTodo).
func (m *EntTodoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EntTodoMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.date != nil {
		fields = append(fields, enttodo.FieldDate)
	}
	if m.startTime != nil {
		fields = append(fields, enttodo.FieldStartTime)
	}
	if m.endTime != nil {
		fields = append(fields, enttodo.FieldEndTime)
	}
	if m.day != nil {
		fields = append(fields, enttodo.FieldDay)
	}
	if m.lesson != nil {
		fields = append(fields, enttodo.FieldLesson)
	}
	if m.homework != nil {
		fields = append(fields, enttodo.FieldHomework)
	}
	if m.status != nil {
		fields = append(fields, enttodo.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EntTodoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case enttodo.FieldDate:
		return m.Date()
	case enttodo.FieldStartTime:
		return m.StartTime()
	case enttodo.FieldEndTime:
		return m.EndTime()
	case enttodo.FieldDay:
		return m.Day()
	case enttodo.FieldLesson:
		return m.Lesson()
	case enttodo.FieldHomework:
		return m.Homework()
	case enttodo.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EntTodoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case enttodo.FieldDate:
		return m.OldDate(ctx)
	case enttodo.FieldStartTime:
		return m.OldStartTime(ctx)
	case enttodo.FieldEndTime:
		return m.OldEndTime(ctx)
	case enttodo.FieldDay:
		return m.OldDay(ctx)
	case enttodo.FieldLesson:
		return m.OldLesson(ctx)
	case enttodo.FieldHomework:
		return m.OldHomework(ctx)
	case enttodo.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown EntTodo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntTodoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case enttodo.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case enttodo.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case enttodo.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case enttodo.FieldDay:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDay(v)
		return nil
	case enttodo.FieldLesson:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLesson(v)
		return nil
	case enttodo.FieldHomework:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHomework(v)
		return nil
	case enttodo.FieldStatus:
		v, ok := value.(enttodo.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown EntTodo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EntTodoMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EntTodoMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntTodoMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EntTodo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EntTodoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(enttodo.FieldStartTime) {
		fields = append(fields, enttodo.FieldStartTime)
	}
	if m.FieldCleared(enttodo.FieldEndTime) {
		fields = append(fields, enttodo.FieldEndTime)
	}
	if m.FieldCleared(enttodo.FieldDay) {
		fields = append(fields, enttodo.FieldDay)
	}
	if m.FieldCleared(enttodo.FieldLesson) {
		fields = append(fields, enttodo.FieldLesson)
	}
	if m.FieldCleared(enttodo.FieldHomework) {
		fields = append(fields, enttodo.FieldHomework)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EntTodoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntTodoMutation) ClearField(name string) error {
	switch name {
	case enttodo.FieldStartTime:
		m.ClearStartTime()
		return nil
	case enttodo.FieldEndTime:
		m.ClearEndTime()
		return nil
	case enttodo.FieldDay:
		m.ClearDay()
		return nil
	case enttodo.FieldLesson:
		m.ClearLesson()
		return nil
	case enttodo.FieldHomework:
		m.ClearHomework()
		return nil
	}
	return fmt.Errorf("unknown EntTodo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EntTodoMutation) ResetField(name string) error {
	switch name {
	case enttodo.FieldDate:
		m.ResetDate()
		return nil
	case enttodo.FieldStartTime:
		m.ResetStartTime()
		return nil
	case enttodo.FieldEndTime:
		m.ResetEndTime()
		return nil
	case enttodo.FieldDay:
		m.ResetDay()
		return nil
	case enttodo.FieldLesson:
		m.ResetLesson()
		return nil
	case enttodo.FieldHomework:
		m.ResetHomework()
		return nil
	case enttodo.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown EntTodo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EntTodoMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.todoFor != nil {
		edges = append(edges, enttodo.EdgeTodoFor)
	}
	if m.ownedBy != nil {
		edges = append(edges, enttodo.EdgeOwnedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EntTodoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case enttodo.EdgeTodoFor:
		if id := m.todoFor; id != nil {
			return []ent.Value{*id}
		}
	case enttodo.EdgeOwnedBy:
		if id := m.ownedBy; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EntTodoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EntTodoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EntTodoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtodoFor {
		edges = append(edges, enttodo.EdgeTodoFor)
	}
	if m.clearedownedBy {
		edges = append(edges, enttodo.EdgeOwnedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EntTodoMutation) EdgeCleared(name string) bool {
	switch name {
	case enttodo.EdgeTodoFor:
		return m.clearedtodoFor
	case enttodo.EdgeOwnedBy:
		return m.clearedownedBy
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EntTodoMutation) ClearEdge(name string) error {
	switch name {
	case enttodo.EdgeTodoFor:
		m.ClearTodoFor()
		return nil
	case enttodo.EdgeOwnedBy:
		m.ClearOwnedBy()
		return nil
	}
	return fmt.Errorf("unknown EntTodo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EntTodoMutation) ResetEdge(name string) error {
	switch name {
	case enttodo.EdgeTodoFor:
		m.ResetTodoFor()
		return nil
	case enttodo.EdgeOwnedBy:
		m.ResetOwnedBy()
		return nil
	}
	return fmt.Errorf("unknown EntTodo edge %s", name)
}

// EntUserMutation represents an operation that mutates the EntUser nodes in the graph.
type EntUserMutation struct {
	config
	op                Op
	typ               string
	id                *int
	name              *string
	email             *string
	password          *string
	phone             *string
	profilePictureUrl *string
	isTutor           *bool
	isStudent         *bool
	isParent          *bool
	clearedFields     map[string]struct{}
	course            map[int]struct{}
	removedcourse     map[int]struct{}
	clearedcourse     bool
	todo              map[int]struct{}
	removedtodo       map[int]struct{}
	clearedtodo       bool
	attendance        map[int]struct{}
	removedattendance map[int]struct{}
	clearedattendance bool
	post              map[int]struct{}
	removedpost       map[int]struct{}
	clearedpost       bool
	comment           map[int]struct{}
	removedcomment    map[int]struct{}
	clearedcomment    bool
	join              map[int]struct{}
	removedjoin       map[int]struct{}
	clearedjoin       bool
	children          map[int]struct{}
	removedchildren   map[int]struct{}
	clearedchildren   bool
	parent            map[int]struct{}
	removedparent     map[int]struct{}
	clearedparent     bool
	student           map[int]struct{}
	removedstudent    map[int]struct{}
	clearedstudent    bool
	tutor             map[int]struct{}
	removedtutor      map[int]struct{}
	clearedtutor      bool
	_SParent          map[int]struct{}
	removed_SParent   map[int]struct{}
	cleared_SParent   bool
	_STutor           map[int]struct{}
	removed_STutor    map[int]struct{}
	cleared_STutor    bool
	canSee            map[int]struct{}
	removedcanSee     map[int]struct{}
	clearedcanSee     bool
	done              bool
	oldValue          func(context.Context) (*EntUser, error)
	predicates        []predicate.EntUser
}

var _ ent.Mutation = (*EntUserMutation)(nil)

// entuserOption allows management of the mutation configuration using functional options.
type entuserOption func(*EntUserMutation)

// newEntUserMutation creates new mutation for the EntUser entity.
func newEntUserMutation(c config, op Op, opts ...entuserOption) *EntUserMutation {
	m := &EntUserMutation{
		config:        c,
		op:            op,
		typ:           TypeEntUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntUserID sets the ID field of the mutation.
func withEntUserID(id int) entuserOption {
	return func(m *EntUserMutation) {
		var (
			err   error
			once  sync.Once
			value *EntUser
		)
		m.oldValue = func(ctx context.Context) (*EntUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EntUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntUser sets the old EntUser of the mutation.
func withEntUser(node *EntUser) entuserOption {
	return func(m *EntUserMutation) {
		m.oldValue = func(context.Context) (*EntUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EntUserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EntUserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EntUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *EntUserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EntUserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the EntUser entity.
// If the EntUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntUserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EntUserMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *EntUserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *EntUserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the EntUser entity.
// If the EntUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntUserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *EntUserMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *EntUserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *EntUserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the EntUser entity.
// If the EntUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntUserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *EntUserMutation) ResetPassword() {
	m.password = nil
}

// SetPhone sets the "phone" field.
func (m *EntUserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *EntUserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the EntUser entity.
// If the EntUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntUserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *EntUserMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[entuser.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *EntUserMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[entuser.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *EntUserMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, entuser.FieldPhone)
}

// SetProfilePictureUrl sets the "profilePictureUrl" field.
func (m *EntUserMutation) SetProfilePictureUrl(s string) {
	m.profilePictureUrl = &s
}

// ProfilePictureUrl returns the value of the "profilePictureUrl" field in the mutation.
func (m *EntUserMutation) ProfilePictureUrl() (r string, exists bool) {
	v := m.profilePictureUrl
	if v == nil {
		return
	}
	return *v, true
}

// OldProfilePictureUrl returns the old "profilePictureUrl" field's value of the EntUser entity.
// If the EntUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntUserMutation) OldProfilePictureUrl(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfilePictureUrl is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfilePictureUrl requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfilePictureUrl: %w", err)
	}
	return oldValue.ProfilePictureUrl, nil
}

// ClearProfilePictureUrl clears the value of the "profilePictureUrl" field.
func (m *EntUserMutation) ClearProfilePictureUrl() {
	m.profilePictureUrl = nil
	m.clearedFields[entuser.FieldProfilePictureUrl] = struct{}{}
}

// ProfilePictureUrlCleared returns if the "profilePictureUrl" field was cleared in this mutation.
func (m *EntUserMutation) ProfilePictureUrlCleared() bool {
	_, ok := m.clearedFields[entuser.FieldProfilePictureUrl]
	return ok
}

// ResetProfilePictureUrl resets all changes to the "profilePictureUrl" field.
func (m *EntUserMutation) ResetProfilePictureUrl() {
	m.profilePictureUrl = nil
	delete(m.clearedFields, entuser.FieldProfilePictureUrl)
}

// SetIsTutor sets the "isTutor" field.
func (m *EntUserMutation) SetIsTutor(b bool) {
	m.isTutor = &b
}

// IsTutor returns the value of the "isTutor" field in the mutation.
func (m *EntUserMutation) IsTutor() (r bool, exists bool) {
	v := m.isTutor
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTutor returns the old "isTutor" field's value of the EntUser entity.
// If the EntUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntUserMutation) OldIsTutor(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTutor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTutor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTutor: %w", err)
	}
	return oldValue.IsTutor, nil
}

// ResetIsTutor resets all changes to the "isTutor" field.
func (m *EntUserMutation) ResetIsTutor() {
	m.isTutor = nil
}

// SetIsStudent sets the "isStudent" field.
func (m *EntUserMutation) SetIsStudent(b bool) {
	m.isStudent = &b
}

// IsStudent returns the value of the "isStudent" field in the mutation.
func (m *EntUserMutation) IsStudent() (r bool, exists bool) {
	v := m.isStudent
	if v == nil {
		return
	}
	return *v, true
}

// OldIsStudent returns the old "isStudent" field's value of the EntUser entity.
// If the EntUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntUserMutation) OldIsStudent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsStudent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsStudent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsStudent: %w", err)
	}
	return oldValue.IsStudent, nil
}

// ResetIsStudent resets all changes to the "isStudent" field.
func (m *EntUserMutation) ResetIsStudent() {
	m.isStudent = nil
}

// SetIsParent sets the "isParent" field.
func (m *EntUserMutation) SetIsParent(b bool) {
	m.isParent = &b
}

// IsParent returns the value of the "isParent" field in the mutation.
func (m *EntUserMutation) IsParent() (r bool, exists bool) {
	v := m.isParent
	if v == nil {
		return
	}
	return *v, true
}

// OldIsParent returns the old "isParent" field's value of the EntUser entity.
// If the EntUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntUserMutation) OldIsParent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsParent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsParent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsParent: %w", err)
	}
	return oldValue.IsParent, nil
}

// ResetIsParent resets all changes to the "isParent" field.
func (m *EntUserMutation) ResetIsParent() {
	m.isParent = nil
}

// AddCourseIDs adds the "course" edge to the EntCourse entity by ids.
func (m *EntUserMutation) AddCourseIDs(ids ...int) {
	if m.course == nil {
		m.course = make(map[int]struct{})
	}
	for i := range ids {
		m.course[ids[i]] = struct{}{}
	}
}

// ClearCourse clears the "course" edge to the EntCourse entity.
func (m *EntUserMutation) ClearCourse() {
	m.clearedcourse = true
}

// CourseCleared reports if the "course" edge to the EntCourse entity was cleared.
func (m *EntUserMutation) CourseCleared() bool {
	return m.clearedcourse
}

// RemoveCourseIDs removes the "course" edge to the EntCourse entity by IDs.
func (m *EntUserMutation) RemoveCourseIDs(ids ...int) {
	if m.removedcourse == nil {
		m.removedcourse = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.course, ids[i])
		m.removedcourse[ids[i]] = struct{}{}
	}
}

// RemovedCourse returns the removed IDs of the "course" edge to the EntCourse entity.
func (m *EntUserMutation) RemovedCourseIDs() (ids []int) {
	for id := range m.removedcourse {
		ids = append(ids, id)
	}
	return
}

// CourseIDs returns the "course" edge IDs in the mutation.
func (m *EntUserMutation) CourseIDs() (ids []int) {
	for id := range m.course {
		ids = append(ids, id)
	}
	return
}

// ResetCourse resets all changes to the "course" edge.
func (m *EntUserMutation) ResetCourse() {
	m.course = nil
	m.clearedcourse = false
	m.removedcourse = nil
}

// AddTodoIDs adds the "todo" edge to the EntTodo entity by ids.
func (m *EntUserMutation) AddTodoIDs(ids ...int) {
	if m.todo == nil {
		m.todo = make(map[int]struct{})
	}
	for i := range ids {
		m.todo[ids[i]] = struct{}{}
	}
}

// ClearTodo clears the "todo" edge to the EntTodo entity.
func (m *EntUserMutation) ClearTodo() {
	m.clearedtodo = true
}

// TodoCleared reports if the "todo" edge to the EntTodo entity was cleared.
func (m *EntUserMutation) TodoCleared() bool {
	return m.clearedtodo
}

// RemoveTodoIDs removes the "todo" edge to the EntTodo entity by IDs.
func (m *EntUserMutation) RemoveTodoIDs(ids ...int) {
	if m.removedtodo == nil {
		m.removedtodo = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.todo, ids[i])
		m.removedtodo[ids[i]] = struct{}{}
	}
}

// RemovedTodo returns the removed IDs of the "todo" edge to the EntTodo entity.
func (m *EntUserMutation) RemovedTodoIDs() (ids []int) {
	for id := range m.removedtodo {
		ids = append(ids, id)
	}
	return
}

// TodoIDs returns the "todo" edge IDs in the mutation.
func (m *EntUserMutation) TodoIDs() (ids []int) {
	for id := range m.todo {
		ids = append(ids, id)
	}
	return
}

// ResetTodo resets all changes to the "todo" edge.
func (m *EntUserMutation) ResetTodo() {
	m.todo = nil
	m.clearedtodo = false
	m.removedtodo = nil
}

// AddAttendanceIDs adds the "attendance" edge to the EntAttendance entity by ids.
func (m *EntUserMutation) AddAttendanceIDs(ids ...int) {
	if m.attendance == nil {
		m.attendance = make(map[int]struct{})
	}
	for i := range ids {
		m.attendance[ids[i]] = struct{}{}
	}
}

// ClearAttendance clears the "attendance" edge to the EntAttendance entity.
func (m *EntUserMutation) ClearAttendance() {
	m.clearedattendance = true
}

// AttendanceCleared reports if the "attendance" edge to the EntAttendance entity was cleared.
func (m *EntUserMutation) AttendanceCleared() bool {
	return m.clearedattendance
}

// RemoveAttendanceIDs removes the "attendance" edge to the EntAttendance entity by IDs.
func (m *EntUserMutation) RemoveAttendanceIDs(ids ...int) {
	if m.removedattendance == nil {
		m.removedattendance = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.attendance, ids[i])
		m.removedattendance[ids[i]] = struct{}{}
	}
}

// RemovedAttendance returns the removed IDs of the "attendance" edge to the EntAttendance entity.
func (m *EntUserMutation) RemovedAttendanceIDs() (ids []int) {
	for id := range m.removedattendance {
		ids = append(ids, id)
	}
	return
}

// AttendanceIDs returns the "attendance" edge IDs in the mutation.
func (m *EntUserMutation) AttendanceIDs() (ids []int) {
	for id := range m.attendance {
		ids = append(ids, id)
	}
	return
}

// ResetAttendance resets all changes to the "attendance" edge.
func (m *EntUserMutation) ResetAttendance() {
	m.attendance = nil
	m.clearedattendance = false
	m.removedattendance = nil
}

// AddPostIDs adds the "post" edge to the EntPost entity by ids.
func (m *EntUserMutation) AddPostIDs(ids ...int) {
	if m.post == nil {
		m.post = make(map[int]struct{})
	}
	for i := range ids {
		m.post[ids[i]] = struct{}{}
	}
}

// ClearPost clears the "post" edge to the EntPost entity.
func (m *EntUserMutation) ClearPost() {
	m.clearedpost = true
}

// PostCleared reports if the "post" edge to the EntPost entity was cleared.
func (m *EntUserMutation) PostCleared() bool {
	return m.clearedpost
}

// RemovePostIDs removes the "post" edge to the EntPost entity by IDs.
func (m *EntUserMutation) RemovePostIDs(ids ...int) {
	if m.removedpost == nil {
		m.removedpost = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.post, ids[i])
		m.removedpost[ids[i]] = struct{}{}
	}
}

// RemovedPost returns the removed IDs of the "post" edge to the EntPost entity.
func (m *EntUserMutation) RemovedPostIDs() (ids []int) {
	for id := range m.removedpost {
		ids = append(ids, id)
	}
	return
}

// PostIDs returns the "post" edge IDs in the mutation.
func (m *EntUserMutation) PostIDs() (ids []int) {
	for id := range m.post {
		ids = append(ids, id)
	}
	return
}

// ResetPost resets all changes to the "post" edge.
func (m *EntUserMutation) ResetPost() {
	m.post = nil
	m.clearedpost = false
	m.removedpost = nil
}

// AddCommentIDs adds the "comment" edge to the EntComment entity by ids.
func (m *EntUserMutation) AddCommentIDs(ids ...int) {
	if m.comment == nil {
		m.comment = make(map[int]struct{})
	}
	for i := range ids {
		m.comment[ids[i]] = struct{}{}
	}
}

// ClearComment clears the "comment" edge to the EntComment entity.
func (m *EntUserMutation) ClearComment() {
	m.clearedcomment = true
}

// CommentCleared reports if the "comment" edge to the EntComment entity was cleared.
func (m *EntUserMutation) CommentCleared() bool {
	return m.clearedcomment
}

// RemoveCommentIDs removes the "comment" edge to the EntComment entity by IDs.
func (m *EntUserMutation) RemoveCommentIDs(ids ...int) {
	if m.removedcomment == nil {
		m.removedcomment = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.comment, ids[i])
		m.removedcomment[ids[i]] = struct{}{}
	}
}

// RemovedComment returns the removed IDs of the "comment" edge to the EntComment entity.
func (m *EntUserMutation) RemovedCommentIDs() (ids []int) {
	for id := range m.removedcomment {
		ids = append(ids, id)
	}
	return
}

// CommentIDs returns the "comment" edge IDs in the mutation.
func (m *EntUserMutation) CommentIDs() (ids []int) {
	for id := range m.comment {
		ids = append(ids, id)
	}
	return
}

// ResetComment resets all changes to the "comment" edge.
func (m *EntUserMutation) ResetComment() {
	m.comment = nil
	m.clearedcomment = false
	m.removedcomment = nil
}

// AddJoinIDs adds the "join" edge to the EntCourse entity by ids.
func (m *EntUserMutation) AddJoinIDs(ids ...int) {
	if m.join == nil {
		m.join = make(map[int]struct{})
	}
	for i := range ids {
		m.join[ids[i]] = struct{}{}
	}
}

// ClearJoin clears the "join" edge to the EntCourse entity.
func (m *EntUserMutation) ClearJoin() {
	m.clearedjoin = true
}

// JoinCleared reports if the "join" edge to the EntCourse entity was cleared.
func (m *EntUserMutation) JoinCleared() bool {
	return m.clearedjoin
}

// RemoveJoinIDs removes the "join" edge to the EntCourse entity by IDs.
func (m *EntUserMutation) RemoveJoinIDs(ids ...int) {
	if m.removedjoin == nil {
		m.removedjoin = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.join, ids[i])
		m.removedjoin[ids[i]] = struct{}{}
	}
}

// RemovedJoin returns the removed IDs of the "join" edge to the EntCourse entity.
func (m *EntUserMutation) RemovedJoinIDs() (ids []int) {
	for id := range m.removedjoin {
		ids = append(ids, id)
	}
	return
}

// JoinIDs returns the "join" edge IDs in the mutation.
func (m *EntUserMutation) JoinIDs() (ids []int) {
	for id := range m.join {
		ids = append(ids, id)
	}
	return
}

// ResetJoin resets all changes to the "join" edge.
func (m *EntUserMutation) ResetJoin() {
	m.join = nil
	m.clearedjoin = false
	m.removedjoin = nil
}

// AddChildIDs adds the "children" edge to the EntUser entity by ids.
func (m *EntUserMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the EntUser entity.
func (m *EntUserMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the EntUser entity was cleared.
func (m *EntUserMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the EntUser entity by IDs.
func (m *EntUserMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the EntUser entity.
func (m *EntUserMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *EntUserMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *EntUserMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddParentIDs adds the "parent" edge to the EntUser entity by ids.
func (m *EntUserMutation) AddParentIDs(ids ...int) {
	if m.parent == nil {
		m.parent = make(map[int]struct{})
	}
	for i := range ids {
		m.parent[ids[i]] = struct{}{}
	}
}

// ClearParent clears the "parent" edge to the EntUser entity.
func (m *EntUserMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the EntUser entity was cleared.
func (m *EntUserMutation) ParentCleared() bool {
	return m.clearedparent
}

// RemoveParentIDs removes the "parent" edge to the EntUser entity by IDs.
func (m *EntUserMutation) RemoveParentIDs(ids ...int) {
	if m.removedparent == nil {
		m.removedparent = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.parent, ids[i])
		m.removedparent[ids[i]] = struct{}{}
	}
}

// RemovedParent returns the removed IDs of the "parent" edge to the EntUser entity.
func (m *EntUserMutation) RemovedParentIDs() (ids []int) {
	for id := range m.removedparent {
		ids = append(ids, id)
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
func (m *EntUserMutation) ParentIDs() (ids []int) {
	for id := range m.parent {
		ids = append(ids, id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *EntUserMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
	m.removedparent = nil
}

// AddStudentIDs adds the "student" edge to the EntUser entity by ids.
func (m *EntUserMutation) AddStudentIDs(ids ...int) {
	if m.student == nil {
		m.student = make(map[int]struct{})
	}
	for i := range ids {
		m.student[ids[i]] = struct{}{}
	}
}

// ClearStudent clears the "student" edge to the EntUser entity.
func (m *EntUserMutation) ClearStudent() {
	m.clearedstudent = true
}

// StudentCleared reports if the "student" edge to the EntUser entity was cleared.
func (m *EntUserMutation) StudentCleared() bool {
	return m.clearedstudent
}

// RemoveStudentIDs removes the "student" edge to the EntUser entity by IDs.
func (m *EntUserMutation) RemoveStudentIDs(ids ...int) {
	if m.removedstudent == nil {
		m.removedstudent = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.student, ids[i])
		m.removedstudent[ids[i]] = struct{}{}
	}
}

// RemovedStudent returns the removed IDs of the "student" edge to the EntUser entity.
func (m *EntUserMutation) RemovedStudentIDs() (ids []int) {
	for id := range m.removedstudent {
		ids = append(ids, id)
	}
	return
}

// StudentIDs returns the "student" edge IDs in the mutation.
func (m *EntUserMutation) StudentIDs() (ids []int) {
	for id := range m.student {
		ids = append(ids, id)
	}
	return
}

// ResetStudent resets all changes to the "student" edge.
func (m *EntUserMutation) ResetStudent() {
	m.student = nil
	m.clearedstudent = false
	m.removedstudent = nil
}

// AddTutorIDs adds the "tutor" edge to the EntUser entity by ids.
func (m *EntUserMutation) AddTutorIDs(ids ...int) {
	if m.tutor == nil {
		m.tutor = make(map[int]struct{})
	}
	for i := range ids {
		m.tutor[ids[i]] = struct{}{}
	}
}

// ClearTutor clears the "tutor" edge to the EntUser entity.
func (m *EntUserMutation) ClearTutor() {
	m.clearedtutor = true
}

// TutorCleared reports if the "tutor" edge to the EntUser entity was cleared.
func (m *EntUserMutation) TutorCleared() bool {
	return m.clearedtutor
}

// RemoveTutorIDs removes the "tutor" edge to the EntUser entity by IDs.
func (m *EntUserMutation) RemoveTutorIDs(ids ...int) {
	if m.removedtutor == nil {
		m.removedtutor = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tutor, ids[i])
		m.removedtutor[ids[i]] = struct{}{}
	}
}

// RemovedTutor returns the removed IDs of the "tutor" edge to the EntUser entity.
func (m *EntUserMutation) RemovedTutorIDs() (ids []int) {
	for id := range m.removedtutor {
		ids = append(ids, id)
	}
	return
}

// TutorIDs returns the "tutor" edge IDs in the mutation.
func (m *EntUserMutation) TutorIDs() (ids []int) {
	for id := range m.tutor {
		ids = append(ids, id)
	}
	return
}

// ResetTutor resets all changes to the "tutor" edge.
func (m *EntUserMutation) ResetTutor() {
	m.tutor = nil
	m.clearedtutor = false
	m.removedtutor = nil
}

// AddSParentIDs adds the "SParent" edge to the EntUser entity by ids.
func (m *EntUserMutation) AddSParentIDs(ids ...int) {
	if m._SParent == nil {
		m._SParent = make(map[int]struct{})
	}
	for i := range ids {
		m._SParent[ids[i]] = struct{}{}
	}
}

// ClearSParent clears the "SParent" edge to the EntUser entity.
func (m *EntUserMutation) ClearSParent() {
	m.cleared_SParent = true
}

// SParentCleared reports if the "SParent" edge to the EntUser entity was cleared.
func (m *EntUserMutation) SParentCleared() bool {
	return m.cleared_SParent
}

// RemoveSParentIDs removes the "SParent" edge to the EntUser entity by IDs.
func (m *EntUserMutation) RemoveSParentIDs(ids ...int) {
	if m.removed_SParent == nil {
		m.removed_SParent = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._SParent, ids[i])
		m.removed_SParent[ids[i]] = struct{}{}
	}
}

// RemovedSParent returns the removed IDs of the "SParent" edge to the EntUser entity.
func (m *EntUserMutation) RemovedSParentIDs() (ids []int) {
	for id := range m.removed_SParent {
		ids = append(ids, id)
	}
	return
}

// SParentIDs returns the "SParent" edge IDs in the mutation.
func (m *EntUserMutation) SParentIDs() (ids []int) {
	for id := range m._SParent {
		ids = append(ids, id)
	}
	return
}

// ResetSParent resets all changes to the "SParent" edge.
func (m *EntUserMutation) ResetSParent() {
	m._SParent = nil
	m.cleared_SParent = false
	m.removed_SParent = nil
}

// AddSTutorIDs adds the "STutor" edge to the EntUser entity by ids.
func (m *EntUserMutation) AddSTutorIDs(ids ...int) {
	if m._STutor == nil {
		m._STutor = make(map[int]struct{})
	}
	for i := range ids {
		m._STutor[ids[i]] = struct{}{}
	}
}

// ClearSTutor clears the "STutor" edge to the EntUser entity.
func (m *EntUserMutation) ClearSTutor() {
	m.cleared_STutor = true
}

// STutorCleared reports if the "STutor" edge to the EntUser entity was cleared.
func (m *EntUserMutation) STutorCleared() bool {
	return m.cleared_STutor
}

// RemoveSTutorIDs removes the "STutor" edge to the EntUser entity by IDs.
func (m *EntUserMutation) RemoveSTutorIDs(ids ...int) {
	if m.removed_STutor == nil {
		m.removed_STutor = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._STutor, ids[i])
		m.removed_STutor[ids[i]] = struct{}{}
	}
}

// RemovedSTutor returns the removed IDs of the "STutor" edge to the EntUser entity.
func (m *EntUserMutation) RemovedSTutorIDs() (ids []int) {
	for id := range m.removed_STutor {
		ids = append(ids, id)
	}
	return
}

// STutorIDs returns the "STutor" edge IDs in the mutation.
func (m *EntUserMutation) STutorIDs() (ids []int) {
	for id := range m._STutor {
		ids = append(ids, id)
	}
	return
}

// ResetSTutor resets all changes to the "STutor" edge.
func (m *EntUserMutation) ResetSTutor() {
	m._STutor = nil
	m.cleared_STutor = false
	m.removed_STutor = nil
}

// AddCanSeeIDs adds the "canSee" edge to the EntPost entity by ids.
func (m *EntUserMutation) AddCanSeeIDs(ids ...int) {
	if m.canSee == nil {
		m.canSee = make(map[int]struct{})
	}
	for i := range ids {
		m.canSee[ids[i]] = struct{}{}
	}
}

// ClearCanSee clears the "canSee" edge to the EntPost entity.
func (m *EntUserMutation) ClearCanSee() {
	m.clearedcanSee = true
}

// CanSeeCleared reports if the "canSee" edge to the EntPost entity was cleared.
func (m *EntUserMutation) CanSeeCleared() bool {
	return m.clearedcanSee
}

// RemoveCanSeeIDs removes the "canSee" edge to the EntPost entity by IDs.
func (m *EntUserMutation) RemoveCanSeeIDs(ids ...int) {
	if m.removedcanSee == nil {
		m.removedcanSee = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.canSee, ids[i])
		m.removedcanSee[ids[i]] = struct{}{}
	}
}

// RemovedCanSee returns the removed IDs of the "canSee" edge to the EntPost entity.
func (m *EntUserMutation) RemovedCanSeeIDs() (ids []int) {
	for id := range m.removedcanSee {
		ids = append(ids, id)
	}
	return
}

// CanSeeIDs returns the "canSee" edge IDs in the mutation.
func (m *EntUserMutation) CanSeeIDs() (ids []int) {
	for id := range m.canSee {
		ids = append(ids, id)
	}
	return
}

// ResetCanSee resets all changes to the "canSee" edge.
func (m *EntUserMutation) ResetCanSee() {
	m.canSee = nil
	m.clearedcanSee = false
	m.removedcanSee = nil
}

// Where appends a list predicates to the EntUserMutation builder.
func (m *EntUserMutation) Where(ps ...predicate.EntUser) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EntUserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (EntUser).
func (m *EntUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EntUserMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.name != nil {
		fields = append(fields, entuser.FieldName)
	}
	if m.email != nil {
		fields = append(fields, entuser.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, entuser.FieldPassword)
	}
	if m.phone != nil {
		fields = append(fields, entuser.FieldPhone)
	}
	if m.profilePictureUrl != nil {
		fields = append(fields, entuser.FieldProfilePictureUrl)
	}
	if m.isTutor != nil {
		fields = append(fields, entuser.FieldIsTutor)
	}
	if m.isStudent != nil {
		fields = append(fields, entuser.FieldIsStudent)
	}
	if m.isParent != nil {
		fields = append(fields, entuser.FieldIsParent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EntUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entuser.FieldName:
		return m.Name()
	case entuser.FieldEmail:
		return m.Email()
	case entuser.FieldPassword:
		return m.Password()
	case entuser.FieldPhone:
		return m.Phone()
	case entuser.FieldProfilePictureUrl:
		return m.ProfilePictureUrl()
	case entuser.FieldIsTutor:
		return m.IsTutor()
	case entuser.FieldIsStudent:
		return m.IsStudent()
	case entuser.FieldIsParent:
		return m.IsParent()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EntUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entuser.FieldName:
		return m.OldName(ctx)
	case entuser.FieldEmail:
		return m.OldEmail(ctx)
	case entuser.FieldPassword:
		return m.OldPassword(ctx)
	case entuser.FieldPhone:
		return m.OldPhone(ctx)
	case entuser.FieldProfilePictureUrl:
		return m.OldProfilePictureUrl(ctx)
	case entuser.FieldIsTutor:
		return m.OldIsTutor(ctx)
	case entuser.FieldIsStudent:
		return m.OldIsStudent(ctx)
	case entuser.FieldIsParent:
		return m.OldIsParent(ctx)
	}
	return nil, fmt.Errorf("unknown EntUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entuser.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case entuser.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case entuser.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case entuser.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case entuser.FieldProfilePictureUrl:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfilePictureUrl(v)
		return nil
	case entuser.FieldIsTutor:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTutor(v)
		return nil
	case entuser.FieldIsStudent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsStudent(v)
		return nil
	case entuser.FieldIsParent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsParent(v)
		return nil
	}
	return fmt.Errorf("unknown EntUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EntUserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EntUserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EntUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EntUserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(entuser.FieldPhone) {
		fields = append(fields, entuser.FieldPhone)
	}
	if m.FieldCleared(entuser.FieldProfilePictureUrl) {
		fields = append(fields, entuser.FieldProfilePictureUrl)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EntUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntUserMutation) ClearField(name string) error {
	switch name {
	case entuser.FieldPhone:
		m.ClearPhone()
		return nil
	case entuser.FieldProfilePictureUrl:
		m.ClearProfilePictureUrl()
		return nil
	}
	return fmt.Errorf("unknown EntUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EntUserMutation) ResetField(name string) error {
	switch name {
	case entuser.FieldName:
		m.ResetName()
		return nil
	case entuser.FieldEmail:
		m.ResetEmail()
		return nil
	case entuser.FieldPassword:
		m.ResetPassword()
		return nil
	case entuser.FieldPhone:
		m.ResetPhone()
		return nil
	case entuser.FieldProfilePictureUrl:
		m.ResetProfilePictureUrl()
		return nil
	case entuser.FieldIsTutor:
		m.ResetIsTutor()
		return nil
	case entuser.FieldIsStudent:
		m.ResetIsStudent()
		return nil
	case entuser.FieldIsParent:
		m.ResetIsParent()
		return nil
	}
	return fmt.Errorf("unknown EntUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EntUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 13)
	if m.course != nil {
		edges = append(edges, entuser.EdgeCourse)
	}
	if m.todo != nil {
		edges = append(edges, entuser.EdgeTodo)
	}
	if m.attendance != nil {
		edges = append(edges, entuser.EdgeAttendance)
	}
	if m.post != nil {
		edges = append(edges, entuser.EdgePost)
	}
	if m.comment != nil {
		edges = append(edges, entuser.EdgeComment)
	}
	if m.join != nil {
		edges = append(edges, entuser.EdgeJoin)
	}
	if m.children != nil {
		edges = append(edges, entuser.EdgeChildren)
	}
	if m.parent != nil {
		edges = append(edges, entuser.EdgeParent)
	}
	if m.student != nil {
		edges = append(edges, entuser.EdgeStudent)
	}
	if m.tutor != nil {
		edges = append(edges, entuser.EdgeTutor)
	}
	if m._SParent != nil {
		edges = append(edges, entuser.EdgeSParent)
	}
	if m._STutor != nil {
		edges = append(edges, entuser.EdgeSTutor)
	}
	if m.canSee != nil {
		edges = append(edges, entuser.EdgeCanSee)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EntUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case entuser.EdgeCourse:
		ids := make([]ent.Value, 0, len(m.course))
		for id := range m.course {
			ids = append(ids, id)
		}
		return ids
	case entuser.EdgeTodo:
		ids := make([]ent.Value, 0, len(m.todo))
		for id := range m.todo {
			ids = append(ids, id)
		}
		return ids
	case entuser.EdgeAttendance:
		ids := make([]ent.Value, 0, len(m.attendance))
		for id := range m.attendance {
			ids = append(ids, id)
		}
		return ids
	case entuser.EdgePost:
		ids := make([]ent.Value, 0, len(m.post))
		for id := range m.post {
			ids = append(ids, id)
		}
		return ids
	case entuser.EdgeComment:
		ids := make([]ent.Value, 0, len(m.comment))
		for id := range m.comment {
			ids = append(ids, id)
		}
		return ids
	case entuser.EdgeJoin:
		ids := make([]ent.Value, 0, len(m.join))
		for id := range m.join {
			ids = append(ids, id)
		}
		return ids
	case entuser.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case entuser.EdgeParent:
		ids := make([]ent.Value, 0, len(m.parent))
		for id := range m.parent {
			ids = append(ids, id)
		}
		return ids
	case entuser.EdgeStudent:
		ids := make([]ent.Value, 0, len(m.student))
		for id := range m.student {
			ids = append(ids, id)
		}
		return ids
	case entuser.EdgeTutor:
		ids := make([]ent.Value, 0, len(m.tutor))
		for id := range m.tutor {
			ids = append(ids, id)
		}
		return ids
	case entuser.EdgeSParent:
		ids := make([]ent.Value, 0, len(m._SParent))
		for id := range m._SParent {
			ids = append(ids, id)
		}
		return ids
	case entuser.EdgeSTutor:
		ids := make([]ent.Value, 0, len(m._STutor))
		for id := range m._STutor {
			ids = append(ids, id)
		}
		return ids
	case entuser.EdgeCanSee:
		ids := make([]ent.Value, 0, len(m.canSee))
		for id := range m.canSee {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EntUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 13)
	if m.removedcourse != nil {
		edges = append(edges, entuser.EdgeCourse)
	}
	if m.removedtodo != nil {
		edges = append(edges, entuser.EdgeTodo)
	}
	if m.removedattendance != nil {
		edges = append(edges, entuser.EdgeAttendance)
	}
	if m.removedpost != nil {
		edges = append(edges, entuser.EdgePost)
	}
	if m.removedcomment != nil {
		edges = append(edges, entuser.EdgeComment)
	}
	if m.removedjoin != nil {
		edges = append(edges, entuser.EdgeJoin)
	}
	if m.removedchildren != nil {
		edges = append(edges, entuser.EdgeChildren)
	}
	if m.removedparent != nil {
		edges = append(edges, entuser.EdgeParent)
	}
	if m.removedstudent != nil {
		edges = append(edges, entuser.EdgeStudent)
	}
	if m.removedtutor != nil {
		edges = append(edges, entuser.EdgeTutor)
	}
	if m.removed_SParent != nil {
		edges = append(edges, entuser.EdgeSParent)
	}
	if m.removed_STutor != nil {
		edges = append(edges, entuser.EdgeSTutor)
	}
	if m.removedcanSee != nil {
		edges = append(edges, entuser.EdgeCanSee)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EntUserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case entuser.EdgeCourse:
		ids := make([]ent.Value, 0, len(m.removedcourse))
		for id := range m.removedcourse {
			ids = append(ids, id)
		}
		return ids
	case entuser.EdgeTodo:
		ids := make([]ent.Value, 0, len(m.removedtodo))
		for id := range m.removedtodo {
			ids = append(ids, id)
		}
		return ids
	case entuser.EdgeAttendance:
		ids := make([]ent.Value, 0, len(m.removedattendance))
		for id := range m.removedattendance {
			ids = append(ids, id)
		}
		return ids
	case entuser.EdgePost:
		ids := make([]ent.Value, 0, len(m.removedpost))
		for id := range m.removedpost {
			ids = append(ids, id)
		}
		return ids
	case entuser.EdgeComment:
		ids := make([]ent.Value, 0, len(m.removedcomment))
		for id := range m.removedcomment {
			ids = append(ids, id)
		}
		return ids
	case entuser.EdgeJoin:
		ids := make([]ent.Value, 0, len(m.removedjoin))
		for id := range m.removedjoin {
			ids = append(ids, id)
		}
		return ids
	case entuser.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case entuser.EdgeParent:
		ids := make([]ent.Value, 0, len(m.removedparent))
		for id := range m.removedparent {
			ids = append(ids, id)
		}
		return ids
	case entuser.EdgeStudent:
		ids := make([]ent.Value, 0, len(m.removedstudent))
		for id := range m.removedstudent {
			ids = append(ids, id)
		}
		return ids
	case entuser.EdgeTutor:
		ids := make([]ent.Value, 0, len(m.removedtutor))
		for id := range m.removedtutor {
			ids = append(ids, id)
		}
		return ids
	case entuser.EdgeSParent:
		ids := make([]ent.Value, 0, len(m.removed_SParent))
		for id := range m.removed_SParent {
			ids = append(ids, id)
		}
		return ids
	case entuser.EdgeSTutor:
		ids := make([]ent.Value, 0, len(m.removed_STutor))
		for id := range m.removed_STutor {
			ids = append(ids, id)
		}
		return ids
	case entuser.EdgeCanSee:
		ids := make([]ent.Value, 0, len(m.removedcanSee))
		for id := range m.removedcanSee {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EntUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 13)
	if m.clearedcourse {
		edges = append(edges, entuser.EdgeCourse)
	}
	if m.clearedtodo {
		edges = append(edges, entuser.EdgeTodo)
	}
	if m.clearedattendance {
		edges = append(edges, entuser.EdgeAttendance)
	}
	if m.clearedpost {
		edges = append(edges, entuser.EdgePost)
	}
	if m.clearedcomment {
		edges = append(edges, entuser.EdgeComment)
	}
	if m.clearedjoin {
		edges = append(edges, entuser.EdgeJoin)
	}
	if m.clearedchildren {
		edges = append(edges, entuser.EdgeChildren)
	}
	if m.clearedparent {
		edges = append(edges, entuser.EdgeParent)
	}
	if m.clearedstudent {
		edges = append(edges, entuser.EdgeStudent)
	}
	if m.clearedtutor {
		edges = append(edges, entuser.EdgeTutor)
	}
	if m.cleared_SParent {
		edges = append(edges, entuser.EdgeSParent)
	}
	if m.cleared_STutor {
		edges = append(edges, entuser.EdgeSTutor)
	}
	if m.clearedcanSee {
		edges = append(edges, entuser.EdgeCanSee)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EntUserMutation) EdgeCleared(name string) bool {
	switch name {
	case entuser.EdgeCourse:
		return m.clearedcourse
	case entuser.EdgeTodo:
		return m.clearedtodo
	case entuser.EdgeAttendance:
		return m.clearedattendance
	case entuser.EdgePost:
		return m.clearedpost
	case entuser.EdgeComment:
		return m.clearedcomment
	case entuser.EdgeJoin:
		return m.clearedjoin
	case entuser.EdgeChildren:
		return m.clearedchildren
	case entuser.EdgeParent:
		return m.clearedparent
	case entuser.EdgeStudent:
		return m.clearedstudent
	case entuser.EdgeTutor:
		return m.clearedtutor
	case entuser.EdgeSParent:
		return m.cleared_SParent
	case entuser.EdgeSTutor:
		return m.cleared_STutor
	case entuser.EdgeCanSee:
		return m.clearedcanSee
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EntUserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown EntUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EntUserMutation) ResetEdge(name string) error {
	switch name {
	case entuser.EdgeCourse:
		m.ResetCourse()
		return nil
	case entuser.EdgeTodo:
		m.ResetTodo()
		return nil
	case entuser.EdgeAttendance:
		m.ResetAttendance()
		return nil
	case entuser.EdgePost:
		m.ResetPost()
		return nil
	case entuser.EdgeComment:
		m.ResetComment()
		return nil
	case entuser.EdgeJoin:
		m.ResetJoin()
		return nil
	case entuser.EdgeChildren:
		m.ResetChildren()
		return nil
	case entuser.EdgeParent:
		m.ResetParent()
		return nil
	case entuser.EdgeStudent:
		m.ResetStudent()
		return nil
	case entuser.EdgeTutor:
		m.ResetTutor()
		return nil
	case entuser.EdgeSParent:
		m.ResetSParent()
		return nil
	case entuser.EdgeSTutor:
		m.ResetSTutor()
		return nil
	case entuser.EdgeCanSee:
		m.ResetCanSee()
		return nil
	}
	return fmt.Errorf("unknown EntUser edge %s", name)
}
