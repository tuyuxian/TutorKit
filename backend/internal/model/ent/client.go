// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"

	"backend/internal/model/ent/migrate"

	"backend/internal/model/ent/entattendance"
	"backend/internal/model/ent/entcomment"
	"backend/internal/model/ent/entcourse"
	"backend/internal/model/ent/entpost"
	"backend/internal/model/ent/enttodo"
	"backend/internal/model/ent/entuser"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// EntAttendance is the client for interacting with the EntAttendance builders.
	EntAttendance *EntAttendanceClient
	// EntComment is the client for interacting with the EntComment builders.
	EntComment *EntCommentClient
	// EntCourse is the client for interacting with the EntCourse builders.
	EntCourse *EntCourseClient
	// EntPost is the client for interacting with the EntPost builders.
	EntPost *EntPostClient
	// EntTodo is the client for interacting with the EntTodo builders.
	EntTodo *EntTodoClient
	// EntUser is the client for interacting with the EntUser builders.
	EntUser *EntUserClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.EntAttendance = NewEntAttendanceClient(c.config)
	c.EntComment = NewEntCommentClient(c.config)
	c.EntCourse = NewEntCourseClient(c.config)
	c.EntPost = NewEntPostClient(c.config)
	c.EntTodo = NewEntTodoClient(c.config)
	c.EntUser = NewEntUserClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:           ctx,
		config:        cfg,
		EntAttendance: NewEntAttendanceClient(cfg),
		EntComment:    NewEntCommentClient(cfg),
		EntCourse:     NewEntCourseClient(cfg),
		EntPost:       NewEntPostClient(cfg),
		EntTodo:       NewEntTodoClient(cfg),
		EntUser:       NewEntUserClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:           ctx,
		config:        cfg,
		EntAttendance: NewEntAttendanceClient(cfg),
		EntComment:    NewEntCommentClient(cfg),
		EntCourse:     NewEntCourseClient(cfg),
		EntPost:       NewEntPostClient(cfg),
		EntTodo:       NewEntTodoClient(cfg),
		EntUser:       NewEntUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		EntAttendance.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.EntAttendance.Use(hooks...)
	c.EntComment.Use(hooks...)
	c.EntCourse.Use(hooks...)
	c.EntPost.Use(hooks...)
	c.EntTodo.Use(hooks...)
	c.EntUser.Use(hooks...)
}

// EntAttendanceClient is a client for the EntAttendance schema.
type EntAttendanceClient struct {
	config
}

// NewEntAttendanceClient returns a client for the EntAttendance from the given config.
func NewEntAttendanceClient(c config) *EntAttendanceClient {
	return &EntAttendanceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `entattendance.Hooks(f(g(h())))`.
func (c *EntAttendanceClient) Use(hooks ...Hook) {
	c.hooks.EntAttendance = append(c.hooks.EntAttendance, hooks...)
}

// Create returns a builder for creating a EntAttendance entity.
func (c *EntAttendanceClient) Create() *EntAttendanceCreate {
	mutation := newEntAttendanceMutation(c.config, OpCreate)
	return &EntAttendanceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EntAttendance entities.
func (c *EntAttendanceClient) CreateBulk(builders ...*EntAttendanceCreate) *EntAttendanceCreateBulk {
	return &EntAttendanceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EntAttendance.
func (c *EntAttendanceClient) Update() *EntAttendanceUpdate {
	mutation := newEntAttendanceMutation(c.config, OpUpdate)
	return &EntAttendanceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EntAttendanceClient) UpdateOne(ea *EntAttendance) *EntAttendanceUpdateOne {
	mutation := newEntAttendanceMutation(c.config, OpUpdateOne, withEntAttendance(ea))
	return &EntAttendanceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EntAttendanceClient) UpdateOneID(id int) *EntAttendanceUpdateOne {
	mutation := newEntAttendanceMutation(c.config, OpUpdateOne, withEntAttendanceID(id))
	return &EntAttendanceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EntAttendance.
func (c *EntAttendanceClient) Delete() *EntAttendanceDelete {
	mutation := newEntAttendanceMutation(c.config, OpDelete)
	return &EntAttendanceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EntAttendanceClient) DeleteOne(ea *EntAttendance) *EntAttendanceDeleteOne {
	return c.DeleteOneID(ea.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *EntAttendanceClient) DeleteOneID(id int) *EntAttendanceDeleteOne {
	builder := c.Delete().Where(entattendance.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EntAttendanceDeleteOne{builder}
}

// Query returns a query builder for EntAttendance.
func (c *EntAttendanceClient) Query() *EntAttendanceQuery {
	return &EntAttendanceQuery{
		config: c.config,
	}
}

// Get returns a EntAttendance entity by its id.
func (c *EntAttendanceClient) Get(ctx context.Context, id int) (*EntAttendance, error) {
	return c.Query().Where(entattendance.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EntAttendanceClient) GetX(ctx context.Context, id int) *EntAttendance {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAttendanceFor queries the attendanceFor edge of a EntAttendance.
func (c *EntAttendanceClient) QueryAttendanceFor(ea *EntAttendance) *EntCourseQuery {
	query := &EntCourseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ea.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entattendance.Table, entattendance.FieldID, id),
			sqlgraph.To(entcourse.Table, entcourse.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, entattendance.AttendanceForTable, entattendance.AttendanceForColumn),
		)
		fromV = sqlgraph.Neighbors(ea.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOwnedBy queries the ownedBy edge of a EntAttendance.
func (c *EntAttendanceClient) QueryOwnedBy(ea *EntAttendance) *EntUserQuery {
	query := &EntUserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ea.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entattendance.Table, entattendance.FieldID, id),
			sqlgraph.To(entuser.Table, entuser.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, entattendance.OwnedByTable, entattendance.OwnedByColumn),
		)
		fromV = sqlgraph.Neighbors(ea.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EntAttendanceClient) Hooks() []Hook {
	return c.hooks.EntAttendance
}

// EntCommentClient is a client for the EntComment schema.
type EntCommentClient struct {
	config
}

// NewEntCommentClient returns a client for the EntComment from the given config.
func NewEntCommentClient(c config) *EntCommentClient {
	return &EntCommentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `entcomment.Hooks(f(g(h())))`.
func (c *EntCommentClient) Use(hooks ...Hook) {
	c.hooks.EntComment = append(c.hooks.EntComment, hooks...)
}

// Create returns a builder for creating a EntComment entity.
func (c *EntCommentClient) Create() *EntCommentCreate {
	mutation := newEntCommentMutation(c.config, OpCreate)
	return &EntCommentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EntComment entities.
func (c *EntCommentClient) CreateBulk(builders ...*EntCommentCreate) *EntCommentCreateBulk {
	return &EntCommentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EntComment.
func (c *EntCommentClient) Update() *EntCommentUpdate {
	mutation := newEntCommentMutation(c.config, OpUpdate)
	return &EntCommentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EntCommentClient) UpdateOne(ec *EntComment) *EntCommentUpdateOne {
	mutation := newEntCommentMutation(c.config, OpUpdateOne, withEntComment(ec))
	return &EntCommentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EntCommentClient) UpdateOneID(id int) *EntCommentUpdateOne {
	mutation := newEntCommentMutation(c.config, OpUpdateOne, withEntCommentID(id))
	return &EntCommentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EntComment.
func (c *EntCommentClient) Delete() *EntCommentDelete {
	mutation := newEntCommentMutation(c.config, OpDelete)
	return &EntCommentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EntCommentClient) DeleteOne(ec *EntComment) *EntCommentDeleteOne {
	return c.DeleteOneID(ec.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *EntCommentClient) DeleteOneID(id int) *EntCommentDeleteOne {
	builder := c.Delete().Where(entcomment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EntCommentDeleteOne{builder}
}

// Query returns a query builder for EntComment.
func (c *EntCommentClient) Query() *EntCommentQuery {
	return &EntCommentQuery{
		config: c.config,
	}
}

// Get returns a EntComment entity by its id.
func (c *EntCommentClient) Get(ctx context.Context, id int) (*EntComment, error) {
	return c.Query().Where(entcomment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EntCommentClient) GetX(ctx context.Context, id int) *EntComment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBelongsTo queries the belongsTo edge of a EntComment.
func (c *EntCommentClient) QueryBelongsTo(ec *EntComment) *EntPostQuery {
	query := &EntPostQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ec.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entcomment.Table, entcomment.FieldID, id),
			sqlgraph.To(entpost.Table, entpost.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, entcomment.BelongsToTable, entcomment.BelongsToColumn),
		)
		fromV = sqlgraph.Neighbors(ec.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOwnedBy queries the ownedBy edge of a EntComment.
func (c *EntCommentClient) QueryOwnedBy(ec *EntComment) *EntUserQuery {
	query := &EntUserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ec.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entcomment.Table, entcomment.FieldID, id),
			sqlgraph.To(entuser.Table, entuser.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, entcomment.OwnedByTable, entcomment.OwnedByColumn),
		)
		fromV = sqlgraph.Neighbors(ec.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EntCommentClient) Hooks() []Hook {
	return c.hooks.EntComment
}

// EntCourseClient is a client for the EntCourse schema.
type EntCourseClient struct {
	config
}

// NewEntCourseClient returns a client for the EntCourse from the given config.
func NewEntCourseClient(c config) *EntCourseClient {
	return &EntCourseClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `entcourse.Hooks(f(g(h())))`.
func (c *EntCourseClient) Use(hooks ...Hook) {
	c.hooks.EntCourse = append(c.hooks.EntCourse, hooks...)
}

// Create returns a builder for creating a EntCourse entity.
func (c *EntCourseClient) Create() *EntCourseCreate {
	mutation := newEntCourseMutation(c.config, OpCreate)
	return &EntCourseCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EntCourse entities.
func (c *EntCourseClient) CreateBulk(builders ...*EntCourseCreate) *EntCourseCreateBulk {
	return &EntCourseCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EntCourse.
func (c *EntCourseClient) Update() *EntCourseUpdate {
	mutation := newEntCourseMutation(c.config, OpUpdate)
	return &EntCourseUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EntCourseClient) UpdateOne(ec *EntCourse) *EntCourseUpdateOne {
	mutation := newEntCourseMutation(c.config, OpUpdateOne, withEntCourse(ec))
	return &EntCourseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EntCourseClient) UpdateOneID(id int) *EntCourseUpdateOne {
	mutation := newEntCourseMutation(c.config, OpUpdateOne, withEntCourseID(id))
	return &EntCourseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EntCourse.
func (c *EntCourseClient) Delete() *EntCourseDelete {
	mutation := newEntCourseMutation(c.config, OpDelete)
	return &EntCourseDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EntCourseClient) DeleteOne(ec *EntCourse) *EntCourseDeleteOne {
	return c.DeleteOneID(ec.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *EntCourseClient) DeleteOneID(id int) *EntCourseDeleteOne {
	builder := c.Delete().Where(entcourse.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EntCourseDeleteOne{builder}
}

// Query returns a query builder for EntCourse.
func (c *EntCourseClient) Query() *EntCourseQuery {
	return &EntCourseQuery{
		config: c.config,
	}
}

// Get returns a EntCourse entity by its id.
func (c *EntCourseClient) Get(ctx context.Context, id int) (*EntCourse, error) {
	return c.Query().Where(entcourse.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EntCourseClient) GetX(ctx context.Context, id int) *EntCourse {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTodo queries the todo edge of a EntCourse.
func (c *EntCourseClient) QueryTodo(ec *EntCourse) *EntTodoQuery {
	query := &EntTodoQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ec.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entcourse.Table, entcourse.FieldID, id),
			sqlgraph.To(enttodo.Table, enttodo.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, entcourse.TodoTable, entcourse.TodoColumn),
		)
		fromV = sqlgraph.Neighbors(ec.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAttendance queries the attendance edge of a EntCourse.
func (c *EntCourseClient) QueryAttendance(ec *EntCourse) *EntAttendanceQuery {
	query := &EntAttendanceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ec.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entcourse.Table, entcourse.FieldID, id),
			sqlgraph.To(entattendance.Table, entattendance.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, entcourse.AttendanceTable, entcourse.AttendanceColumn),
		)
		fromV = sqlgraph.Neighbors(ec.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPost queries the post edge of a EntCourse.
func (c *EntCourseClient) QueryPost(ec *EntCourse) *EntPostQuery {
	query := &EntPostQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ec.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entcourse.Table, entcourse.FieldID, id),
			sqlgraph.To(entpost.Table, entpost.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, entcourse.PostTable, entcourse.PostColumn),
		)
		fromV = sqlgraph.Neighbors(ec.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOwnedBy queries the ownedBy edge of a EntCourse.
func (c *EntCourseClient) QueryOwnedBy(ec *EntCourse) *EntUserQuery {
	query := &EntUserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ec.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entcourse.Table, entcourse.FieldID, id),
			sqlgraph.To(entuser.Table, entuser.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, entcourse.OwnedByTable, entcourse.OwnedByPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(ec.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryJoinedBy queries the joinedBy edge of a EntCourse.
func (c *EntCourseClient) QueryJoinedBy(ec *EntCourse) *EntUserQuery {
	query := &EntUserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ec.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entcourse.Table, entcourse.FieldID, id),
			sqlgraph.To(entuser.Table, entuser.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, entcourse.JoinedByTable, entcourse.JoinedByPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(ec.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EntCourseClient) Hooks() []Hook {
	return c.hooks.EntCourse
}

// EntPostClient is a client for the EntPost schema.
type EntPostClient struct {
	config
}

// NewEntPostClient returns a client for the EntPost from the given config.
func NewEntPostClient(c config) *EntPostClient {
	return &EntPostClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `entpost.Hooks(f(g(h())))`.
func (c *EntPostClient) Use(hooks ...Hook) {
	c.hooks.EntPost = append(c.hooks.EntPost, hooks...)
}

// Create returns a builder for creating a EntPost entity.
func (c *EntPostClient) Create() *EntPostCreate {
	mutation := newEntPostMutation(c.config, OpCreate)
	return &EntPostCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EntPost entities.
func (c *EntPostClient) CreateBulk(builders ...*EntPostCreate) *EntPostCreateBulk {
	return &EntPostCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EntPost.
func (c *EntPostClient) Update() *EntPostUpdate {
	mutation := newEntPostMutation(c.config, OpUpdate)
	return &EntPostUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EntPostClient) UpdateOne(ep *EntPost) *EntPostUpdateOne {
	mutation := newEntPostMutation(c.config, OpUpdateOne, withEntPost(ep))
	return &EntPostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EntPostClient) UpdateOneID(id int) *EntPostUpdateOne {
	mutation := newEntPostMutation(c.config, OpUpdateOne, withEntPostID(id))
	return &EntPostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EntPost.
func (c *EntPostClient) Delete() *EntPostDelete {
	mutation := newEntPostMutation(c.config, OpDelete)
	return &EntPostDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EntPostClient) DeleteOne(ep *EntPost) *EntPostDeleteOne {
	return c.DeleteOneID(ep.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *EntPostClient) DeleteOneID(id int) *EntPostDeleteOne {
	builder := c.Delete().Where(entpost.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EntPostDeleteOne{builder}
}

// Query returns a query builder for EntPost.
func (c *EntPostClient) Query() *EntPostQuery {
	return &EntPostQuery{
		config: c.config,
	}
}

// Get returns a EntPost entity by its id.
func (c *EntPostClient) Get(ctx context.Context, id int) (*EntPost, error) {
	return c.Query().Where(entpost.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EntPostClient) GetX(ctx context.Context, id int) *EntPost {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryComment queries the comment edge of a EntPost.
func (c *EntPostClient) QueryComment(ep *EntPost) *EntCommentQuery {
	query := &EntCommentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ep.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entpost.Table, entpost.FieldID, id),
			sqlgraph.To(entcomment.Table, entcomment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, entpost.CommentTable, entpost.CommentColumn),
		)
		fromV = sqlgraph.Neighbors(ep.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryShareWith queries the shareWith edge of a EntPost.
func (c *EntPostClient) QueryShareWith(ep *EntPost) *EntUserQuery {
	query := &EntUserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ep.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entpost.Table, entpost.FieldID, id),
			sqlgraph.To(entuser.Table, entuser.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, entpost.ShareWithTable, entpost.ShareWithPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(ep.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBelongsTo queries the belongsTo edge of a EntPost.
func (c *EntPostClient) QueryBelongsTo(ep *EntPost) *EntCourseQuery {
	query := &EntCourseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ep.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entpost.Table, entpost.FieldID, id),
			sqlgraph.To(entcourse.Table, entcourse.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, entpost.BelongsToTable, entpost.BelongsToColumn),
		)
		fromV = sqlgraph.Neighbors(ep.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOwnedBy queries the ownedBy edge of a EntPost.
func (c *EntPostClient) QueryOwnedBy(ep *EntPost) *EntUserQuery {
	query := &EntUserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ep.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entpost.Table, entpost.FieldID, id),
			sqlgraph.To(entuser.Table, entuser.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, entpost.OwnedByTable, entpost.OwnedByColumn),
		)
		fromV = sqlgraph.Neighbors(ep.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EntPostClient) Hooks() []Hook {
	return c.hooks.EntPost
}

// EntTodoClient is a client for the EntTodo schema.
type EntTodoClient struct {
	config
}

// NewEntTodoClient returns a client for the EntTodo from the given config.
func NewEntTodoClient(c config) *EntTodoClient {
	return &EntTodoClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `enttodo.Hooks(f(g(h())))`.
func (c *EntTodoClient) Use(hooks ...Hook) {
	c.hooks.EntTodo = append(c.hooks.EntTodo, hooks...)
}

// Create returns a builder for creating a EntTodo entity.
func (c *EntTodoClient) Create() *EntTodoCreate {
	mutation := newEntTodoMutation(c.config, OpCreate)
	return &EntTodoCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EntTodo entities.
func (c *EntTodoClient) CreateBulk(builders ...*EntTodoCreate) *EntTodoCreateBulk {
	return &EntTodoCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EntTodo.
func (c *EntTodoClient) Update() *EntTodoUpdate {
	mutation := newEntTodoMutation(c.config, OpUpdate)
	return &EntTodoUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EntTodoClient) UpdateOne(et *EntTodo) *EntTodoUpdateOne {
	mutation := newEntTodoMutation(c.config, OpUpdateOne, withEntTodo(et))
	return &EntTodoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EntTodoClient) UpdateOneID(id int) *EntTodoUpdateOne {
	mutation := newEntTodoMutation(c.config, OpUpdateOne, withEntTodoID(id))
	return &EntTodoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EntTodo.
func (c *EntTodoClient) Delete() *EntTodoDelete {
	mutation := newEntTodoMutation(c.config, OpDelete)
	return &EntTodoDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EntTodoClient) DeleteOne(et *EntTodo) *EntTodoDeleteOne {
	return c.DeleteOneID(et.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *EntTodoClient) DeleteOneID(id int) *EntTodoDeleteOne {
	builder := c.Delete().Where(enttodo.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EntTodoDeleteOne{builder}
}

// Query returns a query builder for EntTodo.
func (c *EntTodoClient) Query() *EntTodoQuery {
	return &EntTodoQuery{
		config: c.config,
	}
}

// Get returns a EntTodo entity by its id.
func (c *EntTodoClient) Get(ctx context.Context, id int) (*EntTodo, error) {
	return c.Query().Where(enttodo.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EntTodoClient) GetX(ctx context.Context, id int) *EntTodo {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTodoFor queries the todoFor edge of a EntTodo.
func (c *EntTodoClient) QueryTodoFor(et *EntTodo) *EntCourseQuery {
	query := &EntCourseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := et.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(enttodo.Table, enttodo.FieldID, id),
			sqlgraph.To(entcourse.Table, entcourse.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, enttodo.TodoForTable, enttodo.TodoForColumn),
		)
		fromV = sqlgraph.Neighbors(et.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOwnedBy queries the ownedBy edge of a EntTodo.
func (c *EntTodoClient) QueryOwnedBy(et *EntTodo) *EntUserQuery {
	query := &EntUserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := et.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(enttodo.Table, enttodo.FieldID, id),
			sqlgraph.To(entuser.Table, entuser.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, enttodo.OwnedByTable, enttodo.OwnedByColumn),
		)
		fromV = sqlgraph.Neighbors(et.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EntTodoClient) Hooks() []Hook {
	return c.hooks.EntTodo
}

// EntUserClient is a client for the EntUser schema.
type EntUserClient struct {
	config
}

// NewEntUserClient returns a client for the EntUser from the given config.
func NewEntUserClient(c config) *EntUserClient {
	return &EntUserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `entuser.Hooks(f(g(h())))`.
func (c *EntUserClient) Use(hooks ...Hook) {
	c.hooks.EntUser = append(c.hooks.EntUser, hooks...)
}

// Create returns a builder for creating a EntUser entity.
func (c *EntUserClient) Create() *EntUserCreate {
	mutation := newEntUserMutation(c.config, OpCreate)
	return &EntUserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EntUser entities.
func (c *EntUserClient) CreateBulk(builders ...*EntUserCreate) *EntUserCreateBulk {
	return &EntUserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EntUser.
func (c *EntUserClient) Update() *EntUserUpdate {
	mutation := newEntUserMutation(c.config, OpUpdate)
	return &EntUserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EntUserClient) UpdateOne(eu *EntUser) *EntUserUpdateOne {
	mutation := newEntUserMutation(c.config, OpUpdateOne, withEntUser(eu))
	return &EntUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EntUserClient) UpdateOneID(id int) *EntUserUpdateOne {
	mutation := newEntUserMutation(c.config, OpUpdateOne, withEntUserID(id))
	return &EntUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EntUser.
func (c *EntUserClient) Delete() *EntUserDelete {
	mutation := newEntUserMutation(c.config, OpDelete)
	return &EntUserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EntUserClient) DeleteOne(eu *EntUser) *EntUserDeleteOne {
	return c.DeleteOneID(eu.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *EntUserClient) DeleteOneID(id int) *EntUserDeleteOne {
	builder := c.Delete().Where(entuser.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EntUserDeleteOne{builder}
}

// Query returns a query builder for EntUser.
func (c *EntUserClient) Query() *EntUserQuery {
	return &EntUserQuery{
		config: c.config,
	}
}

// Get returns a EntUser entity by its id.
func (c *EntUserClient) Get(ctx context.Context, id int) (*EntUser, error) {
	return c.Query().Where(entuser.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EntUserClient) GetX(ctx context.Context, id int) *EntUser {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCourse queries the course edge of a EntUser.
func (c *EntUserClient) QueryCourse(eu *EntUser) *EntCourseQuery {
	query := &EntCourseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := eu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entuser.Table, entuser.FieldID, id),
			sqlgraph.To(entcourse.Table, entcourse.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, entuser.CourseTable, entuser.CoursePrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(eu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTodo queries the todo edge of a EntUser.
func (c *EntUserClient) QueryTodo(eu *EntUser) *EntTodoQuery {
	query := &EntTodoQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := eu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entuser.Table, entuser.FieldID, id),
			sqlgraph.To(enttodo.Table, enttodo.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, entuser.TodoTable, entuser.TodoColumn),
		)
		fromV = sqlgraph.Neighbors(eu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAttendance queries the attendance edge of a EntUser.
func (c *EntUserClient) QueryAttendance(eu *EntUser) *EntAttendanceQuery {
	query := &EntAttendanceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := eu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entuser.Table, entuser.FieldID, id),
			sqlgraph.To(entattendance.Table, entattendance.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, entuser.AttendanceTable, entuser.AttendanceColumn),
		)
		fromV = sqlgraph.Neighbors(eu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPost queries the post edge of a EntUser.
func (c *EntUserClient) QueryPost(eu *EntUser) *EntPostQuery {
	query := &EntPostQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := eu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entuser.Table, entuser.FieldID, id),
			sqlgraph.To(entpost.Table, entpost.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, entuser.PostTable, entuser.PostColumn),
		)
		fromV = sqlgraph.Neighbors(eu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComment queries the comment edge of a EntUser.
func (c *EntUserClient) QueryComment(eu *EntUser) *EntCommentQuery {
	query := &EntCommentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := eu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entuser.Table, entuser.FieldID, id),
			sqlgraph.To(entcomment.Table, entcomment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, entuser.CommentTable, entuser.CommentColumn),
		)
		fromV = sqlgraph.Neighbors(eu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryJoin queries the join edge of a EntUser.
func (c *EntUserClient) QueryJoin(eu *EntUser) *EntCourseQuery {
	query := &EntCourseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := eu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entuser.Table, entuser.FieldID, id),
			sqlgraph.To(entcourse.Table, entcourse.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, entuser.JoinTable, entuser.JoinPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(eu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildren queries the children edge of a EntUser.
func (c *EntUserClient) QueryChildren(eu *EntUser) *EntUserQuery {
	query := &EntUserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := eu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entuser.Table, entuser.FieldID, id),
			sqlgraph.To(entuser.Table, entuser.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, entuser.ChildrenTable, entuser.ChildrenPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(eu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParent queries the parent edge of a EntUser.
func (c *EntUserClient) QueryParent(eu *EntUser) *EntUserQuery {
	query := &EntUserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := eu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entuser.Table, entuser.FieldID, id),
			sqlgraph.To(entuser.Table, entuser.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, entuser.ParentTable, entuser.ParentPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(eu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStudent queries the student edge of a EntUser.
func (c *EntUserClient) QueryStudent(eu *EntUser) *EntUserQuery {
	query := &EntUserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := eu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entuser.Table, entuser.FieldID, id),
			sqlgraph.To(entuser.Table, entuser.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, entuser.StudentTable, entuser.StudentPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(eu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTutor queries the tutor edge of a EntUser.
func (c *EntUserClient) QueryTutor(eu *EntUser) *EntUserQuery {
	query := &EntUserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := eu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entuser.Table, entuser.FieldID, id),
			sqlgraph.To(entuser.Table, entuser.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, entuser.TutorTable, entuser.TutorPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(eu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySParent queries the SParent edge of a EntUser.
func (c *EntUserClient) QuerySParent(eu *EntUser) *EntUserQuery {
	query := &EntUserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := eu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entuser.Table, entuser.FieldID, id),
			sqlgraph.To(entuser.Table, entuser.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, entuser.SParentTable, entuser.SParentPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(eu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySTutor queries the STutor edge of a EntUser.
func (c *EntUserClient) QuerySTutor(eu *EntUser) *EntUserQuery {
	query := &EntUserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := eu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entuser.Table, entuser.FieldID, id),
			sqlgraph.To(entuser.Table, entuser.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, entuser.STutorTable, entuser.STutorPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(eu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCanSee queries the canSee edge of a EntUser.
func (c *EntUserClient) QueryCanSee(eu *EntUser) *EntPostQuery {
	query := &EntPostQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := eu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entuser.Table, entuser.FieldID, id),
			sqlgraph.To(entpost.Table, entpost.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, entuser.CanSeeTable, entuser.CanSeePrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(eu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EntUserClient) Hooks() []Hook {
	return c.hooks.EntUser
}
